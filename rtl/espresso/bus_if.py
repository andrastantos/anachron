#!/usr/bin/python3
from random import *
from typing import *
from silicon import *
try:
    from .brew_types import *
    from .brew_utils import *
    from .scan import ScanWrapper
    from .synth import *
except ImportError:
    from brew_types import *
    from brew_utils import *
    from scan import ScanWrapper
    from synth import *

"""
TODO:

Changes needed to co-exist with Disco and fix DMA timing.

DONE Espresso should (when programmed to) delay the start of a DRAM/I/O/DMA cycle if dram.n_wait is asserted.
DONE Espresso should (when programmed to) back-off DRAM cycle, if dram.n_wait is asserted in the same cycle as dram.n_ras_X is. Then, wait until dram.n_wait is de-asserted and retry.
DONE Espresso should (when programmed to) delay asserting dram.n_dack until after dram.n_ras is asserted and confirmed not-interfering with dram.n_wait

DONE Espresso should delay asserting dram.n_cas_X during DMA cycles until dram.n_wait is de-asserted.

DONE Espresso should sample dram.n_wait on the falling edge of clk.

Espresso should sample DMA requests on the falling edge of clk (this is in cpu_dma.py).

"""

"""
Bus interface for Espresso.

This module is not part of the main pipeline, it sits on the side.

It does the following:
- Takes (arbitrated) requests from all internal memory clients such as
  fetch, memory, refresh or DMA.
- Deals with external bust-contetion and arbitration
- Deals with internal/external wait-states
- Generates appropriately timed signals for (NMOS) DRAM chips
- Sends data (in case of reads) back to clients

Notes:

1. Bursts are auto-recognized by BusIf. In other words, there's a comparator for
   the top bits and bursts will last as long as possible, even across different
   clients. Bursts are broken on 256-word page boundaries.
2. Bursts can and match read/write cycles. DRAM_nWE follows timing of DRAM_ADDR.
3. Each beat can have independent byte-enables. Bytes that are disabled will see
   their corresponding nCAS_X pulses removed.
3. Bursts are not breakable by clients. They simply stop requesting and the
   arbiter may select a different client at that point which may or may not
   continue with the burst.
4. BusIf *can* introduce back-pressure by de-asserting 'ready' whenever it feels
   like it. These can be due to internal or external wait-states, breaking of
   bursts or losing bus-arbitration.
5. Every accepted transfer induces a response cycle after the corresponding
   bus-cycle completes. The data field might be invalid for non-read requests.

The input signals are fed through re-synchronizer stages as follows:
1. DRAM_N_WAIT is double-registered on different edges.
2. DRAM_DATA on reads is registered on both edges, then re-registered on rising
   edge



    4-beat burst with no wait
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><   COL 0  ><   COL 1  ><   COL 2  ><      COL 3      >-------------------------------------
    dram.data wr    -------------------<DB_A>< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 ><    D7     >-------------------------------------
    dram.data rd    -------------------<DB_A>---< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 >< D7 >-----------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                  ^---- Subsequent beats of the burst accepted
                                End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*__

    4-beat burst with initial wait
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________________________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------------------< ROW><   COL 0  ><   COL 1  ><   COL 2  ><       COL 3     >-------------------------
    dram.data wr    -------------------------------<DB_A>< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 ><    D7     >-------------------------
    dram.data rd    -------------------------------<DB_A>---< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 >< D7 >-----------------------------
    dram.n_wait     *^^^^^^^^\__*________/^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^\____*______/^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted, but held
                                                  ^----- Back-pressure applied to client
                                                              ^---- Subsequent beats of the burst accepted
                                            End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*__

    4-beat burst with row-wait
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________________________________/^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<              ROW           ><   COL 0  ><   COL 1  ><   COL 2  ><      COL 3     >--------------
    dram.data wr    -------------------<            DB_ADDR         >< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 ><    D7    >--------------
    dram.data rd    -------------------<            DB_ADDR         >----< D0 >< D1 >< D2 >< D3 >< D4 >< D5 >< D6 >< D7 >----------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^\__*___________*________/^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^\____*___________*______/^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_______________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^
                                      ^--------- First beat accepted, but held mid-way
                                                  ^----- Second beat accepted, but held
                                                              ^----- Back-pressure applied to client
                                                                                      ^---- Subsequent beats of the burst accepted
                                                        End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\


    4-beat burst with col-wait
    ================================================

                                             !!!!! THIS IS NOT SUPPORTED DUE TO EXTRA IMPLEMENTATION COMPLEXITY !!!!!

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><                 COL 0             ><   COL 1  ><   COL 2  ><      COL 3     >-------------------------
    dram.data wr    -------------------<DB_A>< D0 ><            D1               >< D2 >< D3 >< D4 >< D5 >< D6 ><    D7    >-------------------------
    dram.data rd    -------------------<DB_A>---< D0 >-------------------------< D1 >< D2 >< D3 >< D4 >< D5 >< D6 >< D7 >----------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^\________*___________*____/^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^\_____*___________*_____/^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_______________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*__________________________
    request.ready   ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*__/^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^^^^^^^^^^^^^^^^
                                      ^--------- First beat goes through normally
                                                  ^--------- Second beat accepted, but held
                                                              ^----- Third beat accepted, but held
                                                                          ^----- Back-pressure applied to client
                                                      Subsequent beats of the burst accepted -----^
                                                                    End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\

    Burst break due to page-boundary crossing
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________/^^^^^^^^^^^\___________________________________/^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<ROW0><   COL 0  ><      COL 1     >------------------<ROW1><   COL 2  ><      COL 3     >--------
    dram.data wr    -------------------<DB_A>< D0 >< D1 >< D2 ><    D3    >------------------------< D4 >< D5 >< D6 ><    D7    >--------
    dram.data rd    -------------------<DB_A>---< D0 >< D1 >< D2 >< D3 >------------------------< D4 >< D5 >< D6 >< D7 >-----------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                  ^---- Second beat accepted; page crossing recognized
                                                              ^--- two wait-states are inserted to end burst and start new one
                                                        End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^\

    Refresh cycle with no bus contention
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<    ROW     >------------------------------------------------------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- Request accepted
                                                  ^---- Wait-state inserted for pre-charge
                                                              ^--------- Next request accepted
    response.valid  ______*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*___________*___________*___________*__

    Refresh cycle with initial wait
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------------------<    ROW     >------------------------------------------------------------------------
    dram.n_wait     *^^^^^^^^\__*________/^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^\____*______/^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- Request accepted
                                                  ^---- Wait-state inserted due to bus-conflict
                                                              ^---- Wait-state inserted for pre-charge
                                                                          ^--------- Next request accepted
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*___________*___________*__



    Refresh with row-wait
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<               ROW                 >-------------------------------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^\__*___________*________/^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^\____*___________*______/^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_______________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- Refresh accepted
                                                  ^---- Wait-state inserted for pre-charge
                                                              ^----- Wait-state inserted due to bus-conflict
                                                                          ^----- Wait-state inserted due to bus-conflict
                                                                                      ^---- Next request accepted
    response.valid  ______*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*___________*__


    Burst with 0 internal WS
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><   COL 0  ><      COL 3      >-------------------------------------------------------------
    dram.data wr    -------------------<DB_A>< D0 >< D1 >< D2 ><    D3     >-------------------------------------------------------------
    dram.data rd    -------------------<DB_A>---< D0 >< D1 >< D2 >< D3 >-----------------------------------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                  ^---- Subsequent beats of the burst accepted
                                End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^\_________*___________*___________*___________*__


    Burst with 1 internal WS
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<ROW0><        COL 0         ><            COL 1            >-------------------------------------
    dram.data wr    -------------------<DB_A><    D0    ><    D1    ><    D2    ><        D3       >-------------------------------------
    dram.data rd    -------------------<DB_A>-----------< D0 >------< D1 >-----< D2 >------< D3 >----------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                              ^---- Second beat accepted; page crossing recognized
                                                  ^-----------------------^----- Wait-states are inserted, one for each beat
                                            End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*___________*__


    Burst with 2 internal WS
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________________________________/^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<ROW0><               COL 0              ><                   COL 1                 >-------------
    dram.data wr    -------------------<DB_A><       D0       ><        D1      ><       D2       ><          D3           >-------------
    dram.data rd    -------------------<DB_A>-----------------< D0 >------------< D1 >------------< D2 >------------< D3 >---------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*__/^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                                                      ^---- Second beat accepted; page crossing recognized
                                                  ^-----------^-----------------------^-----------^-- Wait-states are inserted, one for each beat
                                                                                            End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^\


    Burst with 3 internal WS
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________________________________________________________/^^^^^^^^^^^^
    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\___________/^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------<ROW0><                  COL 0                 ><                         COL  1                            >-------------
    dram.data wr    -------------------<DB_A><       D0       ><           D1         ><          D2          ><               D3                  >-------------
    dram.data rd    -------------------<DB_A>-----------------< D0 >------------------< D1 >------------------< D2 >-------------------< D3 >--------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*___________*__/^^^^^^^^*^\_________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                                                      ^---- Second beat accepted; page crossing recognized
                                                  ^-----------^-----------------------^-----------^-- Wait-states are inserted, one for each beat
                                                                                            End of burst; wait-state inserted for pre-charge -----^
    response.valid  ______*___________*___________*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*_/^^^^^^^^^*^\

    Simple Non-DRAM access
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    DRAM_nNREN      ^^^^^^^^^^^^^^^^^^^^\___________________________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><   COL 0  ><   COL 1  ><   COL 2  ><      COL 3      >-------------------------------------
    dram.data wr    -------------------<DB_A><    D0    ><    D1    ><    D2    ><        D3       >-------------------------------------
    dram.data rd    -------------------<DB_A>----------< D0>-------< D1>-------< D2>-------< D3>-----------------------------------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*______________
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^^^^
                                      ^--------- First beat accepted
                                                  ^----- Wait-state inserted to match client and bus-speed
                                                              ^---- Subsequent beats of the burst accepted
                             End of burst; wait-state inserted for nNREN cycling -----^
    response.valid  ______*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*___________*__

    Non-DRAM access with external waits
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    DRAM_nNREN      ^^^^^^^^^^^^^^^^^^^^\__________________________________________________________________________________/^^^^^^^^^^^^^
    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><                   COL 0          ><   COL 1  ><   COL 2  ><      COL 3     >--------------
    dram.data wr    -------------------<DB_A><                    D0            ><    D1    ><    D2    ><       D3       >--------------
    dram.data rd    -------------------<DB_A>----------------------------------< D0>-------< D1>-------< D2>-------< D3>-----------------
    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^\_*___________*_________/^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^\____*___________*______/^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_______________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_________*___________*___________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^^
                                      ^--------- First beat accepted
                                                  ^----- Wait-state inserted to match client and bus-speed
                                                              ^---- Second beat accepted, but held
                                                                          ^----- Wait-state inserted due to external waits
                                                     End of burst; wait-state inserted for nNREN cylcing -----^
    response.valid  ______*___________*___________*___________*___________*___________*___________*_/^^^^^^^^^*^\_________*_/^^^^^^^^^*^\_

    Simple DMA access
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\_______________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram.n_cas_0    ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><      COL 0      >-------------------------------------------------------------------------
    dram.data wr    -------------------<DB_A><       D0        >-------------------------------------------------------------------------
    dram.data rd    -------------------<DB_A>---< D0 >-----------------------------------------------------------------------------------
    NDACK           ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><      COL 0      >-------------------------------------------------------------------------
    dram.data wr    -------------------<DB_A>------<     D0    >-------------------------------------------------------------------------
    dram.data rd    -------------------<DB_A>---------< D0 >-----------------------------------------------------------------------------
    NDACK           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- Cycle accepted           ^----- next request accepted (whatever it might be)
                                                  ^---- DMAs are forced to single-beat
                                                              ^----- wait-state inserted for pre-charge
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*___________*___________*__

    DMA access with internal waits
    ================================================

    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    dram.n_ras_X    ^^^^^^^^^^^^^^^^^^^^\_______________________________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram_n_cas_0   ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><                    COL 0                >-------------------------------------------------
    dram.data wr    -------------------<DB_A><                    D0                   >-------------------------------------------------
    dram.data rd    -------------------<DB_A>---------------------------< D0 >-----------------------------------------------------------
    NDACK           ^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram.n_cas_1    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dram.addr       -------------------< ROW><                   COL 0                 >-------------------------------------------------
    dram.data wr    -------------------<DB_A>------<                D0                 >-------------------------------------------------
    dram.data rd    -------------------<DB_A>---------------------------------< D0 >-----------------------------------------------------
    NDACK           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____________________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    dram.n_wait     *^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^
    dram_n_wait_i1  ^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
    dram_n_wait_i2  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    clk             \_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^
    request.valid   ______*/^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*\__________*___________*___________*__
    request.ready   ^^^^^^*^^^^^^^^^^^*^\_________*___________*___________*___________*_/^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^^^^^^^^^^*^^
                                      ^--------- Cycle accepted                                   ^----- next request accepted
                                                  ^---- Wait-states
                                                              ^---- DMAs are forced to single-beat
                                                                                      ^----- wait-state inserted for pre-charge
    response.valid  ______*___________*___________*___________*_/^^^^^^^^^*^\_________*___________*___________*___________*___________*__


General notes:
1. External waits can only be inserted on 'CAS_B' cycles. This has consequences
   for non-DRAM cycles; i.e. CAS timing must be 'B'-style for these. The BusIf
   behavior for external wait-states inserted into a DRAM cycle are not defined.
   That is, they probably won't work. The requirement is that DRAM_NWAIT should
   not be asserted for DRAM cycles after any of the CAS signals are asserted.
2. Page breaks combinatorially de-assert req_ready. This is needed to cleanly
   start the second transfer after the break: this way it's simply a second
   transfer.
   (TODO: Is this really necessary? Can we fix this?)
3. A transfer after a page-break is treated as a new transfer. It goes through
   the same bus-conflict detection and resolution procedures as any other bus
   cycle.
4. Drive of ADDR/DATA wires is extended in the prolog beyond the deassertion
   of CAS_X. This is to support (I/O) devices that require non-zero hold times.

DMA transfers:
1. DMAs are alyways 8-bits in size. So either nCAS_A or nCAS_B are active in
   their desginated time-slots
2. NDACK follows the active nCAS_X timing, activated for one or the other half
   of the cycle, depending on address LSB

Non-DRAM transfers:
1. For non-DRAM accesses nCAS_A is repurposed as address 0.
2. Byte enables are not collapsed. That is, reading/writing of 8-bit quantities
   still take 2 bus-cycles.
   (TODO: What would it take to improve this??)

Response latencies:
1. Responses are provided up to three cycles after a request is accepted in case
   of no wait-states. If there are wait-states, this latency can be arbitrarily
   large, but in those cases req_ready is de-asserted for the remainder of the
   cycles. In other words, there could be no more than three outstanding
   requests.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   THAT IS UNLESS WE SUPPORT COL-WAIT CYCLES FOR DRAM. THOSE NEED
   DOUBLE-BUFFERED INPUTS AND THUS FOUR OUTSTANDING TRANSACTIONS.
   THIS IS THE MAIN REASON THEY ARE NOT SUPPORTED.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2. Latency can be reduced by one if we trusted the data input for
   meta-stability. Maybe we can? After all, we control clk-to-cas timing and
   we have external setup/hold requirements with respect to CAS.

   NOTE: read latency is rather important for the processor. One extra cycle
   shaved off here goes a long way.

Wait-states:
1. Odd wait-states add half a cycle to every "CAS-HIGH" phase
2. Even wait-states add half a cycle to every "CAS-LOW" phase
3. RAS is released on the rising edge after the last rising CAS edge
4. RAS extension (at the front-end) is possible through CSRs
5. External wait-states for the RAS-phase is supported for all banks and spaces
6. External wait-states for the CAS-phase is supported only if wait-state is
   greater than 1
7. non-DRAM access with 0 WS will not toggle CAS, will rely on external logic to
   use CLK to understand what to do
8. Pulling dram.n_wait low when no bus-transfer is in progress will delay
   the start of any bus transfers


The 32-bit address space is broken up as follows:

     31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   |PHY|  WS_CODE  |MSS|                                           MEM_SPACE_ADDRESS                                           |BS |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
         29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       |  WS_CODE  |MSS|                                           MEM_SPACE_ADDRESS                                           |
       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  14-bit bank address  |DA3|DA2|DA1|DA0|                           |DBS|                 DRAM_BANK_ADDR                        |
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  16-bit bank address  |DA3|DA2|DA1|DA0|                   |DBS|                     DRAM_BANK_ADDR                            |
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  18-bit bank address  |DA3|DA2|DA1|DA0|           |DBS|                         DRAM_BANK_ADDR                                |
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  20-bit bank address  |DA3|DA2|DA1|DA0|   |DBS|                             DRAM_BANK_ADDR                                    |
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  22-bit bank address  |DA3|DA2|DA1|DBS|                                 DRAM_BANK_ADDR                                        |
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  non-DRAM access      |DA3|DA2|DA1|DA0|                                 DRAM_BANK_ADDR                                        |CA0|
                       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

    PHY:
        if cleared, address is logical and goes through address translation.
        If set, address is physical and is interpreted as-is. This bit is not
        presented to BusIf, it's stripped by the address translation. It's
        shown here for completeness only.
    WS_CODE:
        number of wait-states. See table below for mapping
    MSS:
        Memory space select. 0 selects non-DRAM, 1 selects DRAM memory space
    MEM_SPACE_ADDRESS:
        word-address within the selected space
    BS:
        Byte-select. This is not visible to the BusIf; this information is
        passed in as a pair of 'byte_en' signals.
    DBx:
        Address bits presented on the data-bus (bit x) during the RAS-cycle.
    DBS:
        DRAM bank selects. Decides if RAS_A or RAS_B will be asserted actual
        mapping depends on BANK_SWAP CSR bit.
        NOTE: this bit is also presented on data-bus, bit-0 during the RAS-cycle
        in case of 22-bit bank addressing
    DRAM_BANK_ADDR:
        DRAM bank address. Address bits mapped to the DRAM_ADDR pins
    CA1:
        Reconstructed LSB presented on dram.n_cas_0 for non-DRAM accesses

Wait-state table:

    Code    Wait states
    ------  -----------
      0        14
      1        12
      2        8
      3        6
      4        4
      5        2
      6        1
      7        0

DRAM_BANK_ADDR mapping:

    BusIf has an 11-wire external address bus. This is multiplexed between a RAS
    and a CAS cycle, providing a total of 22 address bits.

    The mapping of DRAM_BANK_ADDR to the 11 external wires is as follows:

                             DRAM ACCESS                NREN ACCESS
    DRAM_BANK_ADDR     RAS PHASE    CAS PHASE    RAS PHASE     CAS PHASE
    ---------          ---------    ---------    ---------     ---------
        0                  7            0            11             0
        1                  8            1            12             1
        2                  9            2            13             2
        3                 10            3            14             3
        4                 11            4            15             4
        5                 12            5            16             5
        6                 13            6            17             6
        7                 15           14            18             7
        8                 17           16            19             8
        9                 19           18            20             9
       10                 21           20            21            10

CSR settings:
    bits      register name         notes
    ------    -------------         -----------------------------
    0-2       BANK_SIZE             0 - 14 bits (  32kByte)
                                    1 - 16 bits ( 128kByte)
                                    2 - 18 bits ( 512kByte)
                                    3 - 20 bits (2048kByte)
                                    4 - 22 bits (8192kByte)
                                    5 - reserved
                                    6 - reserved
                                    7 - reserved
    3         BANK_SWAP             0 - RAS_A for DBS=0, RAS_B for DBS=1
                                    1 - RAS_A for DBS=1, RAS_B for DBS=0
    4         RAS_A_WS              1 - 0 RAS wait-states for RAS_A
                                    0 - 1 RAS wait-state for RAS_A
    5         RAS_B_WS              1 - 0 RAS wait-states for RAS_B
                                    0 - 1 RAS wait-state for RAS_B
    6         NREN_WS               1 - 0 RAS wait-states for NREN
                                    0 - 1 RAS wait-state for NREN

"""
"""
OLD NOTES:
==========
    TODO: really what should happen is that address bit 30 should not partake in wait-state selection, instead
            it should be used by the address calculation unit to determine if logical-to-physical translation needs
            to happen.
    TODO: Espresso should (when programmed to) delay the start of a DRAM/I/O/DMA cycle if dram.n_wait is asserted.
    TODO: Espresso should (when programmed to) back-off DRAM cycle, if dram.n_wait is asserted in the same cycle as dram.n_ras_X is. Then, wait until dram.n_wait is de-asserted and retry.
    TODO: Espresso should (when programmed to) delay asserting dram.n_dack until after dram.n_ras is asserted and confirmed not-interfering with dram.n_wait
    TODO: Espresso should delay asserting dram.n_cas_X during DMA cycles until dram.n_wait is de-asserted.
    TODO: Espresso should sample dram.n_wait on the falling edge of clk.
    TODO: Espresso should sample DMA requests on the falling edge of clk (this is in cpu_dma.py).


    NOTE: wait-states are actually ignored by the bus-interface when interacting with non-DMA DRAM transfers.
            however, DMA transactions do need wait-state designation, so in reality no more than 64MB of DRAM
            can be addressed in each of the spaces
    NOTE: addressing more than 64MB of DRAM is a bit problematic because they can't be contiguous. This isn't
            a big deal for this controller as there aren't enough external banks to get to that high of memory
            configurations anyway. The maximum addressable memory is 16MB in a 2-bank setup.
    NOTE: since addresses are in 16-bit quantities inside here, we're counting bits 30 downwards
"""



class BusIf(Module):
    clk = ClkPort()
    rst = RstPort()

    request = Input(BusIfRequestIf)
    response = Output(BusIfResponseIf)

    # CRS interface for config registers
    reg_if = Input(CsrIf)

    # DRAM interface
    dram = Output(ExternalBusIf)

    # Events
    event_bus_idle = Output(logic)

    def body(self):
        class MemSpaces(Enum):
            dram_0 = 0
            dram_1 = 1
            nren   = 2

        # CSR interface
        #########################
        csr_busif_config = ApbReg()
        dram_bank_size = csr_busif_config.add_field("bank_size",  2, 0, ApbReg.Kind.ctrl).ctrl_port
        dram_bank_swap = csr_busif_config.add_field("bank_swap",  3, 3, ApbReg.Kind.ctrl).ctrl_port
        dram_0_wait =     csr_busif_config.add_field("ras_a_wait", 4, 4, ApbReg.Kind.ctrl).ctrl_port
        dram_1_wait =     csr_busif_config.add_field("ras_b_wait", 5, 5, ApbReg.Kind.ctrl).ctrl_port
        nren_wait =      csr_busif_config.add_field("nren_wait",  6, 6, ApbReg.Kind.ctrl).ctrl_port

        # Input buffer
        #########################

        # We create a slide-buffer here. This one has 0 forward latency,
        # but can hold up to one outstanding transfer, if needed.
        # At least I *think* that's what we need.

        req = Wire(BusIfRequestIf)
        req = ReverseBuf(self.request)

        # Bus FSM
        #########################

        # We have to encode two phases in a single state as
        # the interface is in essence a DDR affair.
        # Instead of *why* we're doing things, let's
        # try to encode *what* we're doing
        class BusIfStates(Enum):
            idle                 = 0 # idle or precharge
            ras_cas0             = 3
            cas0_cas1            = 4
            cas1_cas0            = 5
            cas1_none            = 6
            ras_wait             = 7
            ras_ras              = 8
            cas0_ras             = 9
            cas1_ras             = 10
            cas0_cas0            = 11
            ras_cas1             = 12
            cas1_cas1            = 13

        self.fsm = FSM()

        self.fsm.reset_value   <<= BusIfStates.idle
        self.fsm.default_state <<= BusIfStates.idle

        state = Wire()
        next_state = Wire()
        state <<= self.fsm.state
        next_state <<= self.fsm.next_state

        req_progress = req.ready & req.valid
        req_wait_states_l = Select(req.addr[29:27], 14,12,8,6,4,2,1,0)
        req_wait_states = Reg(req_wait_states_l, clock_en = req_progress)
        wait_states = Wire(Unsigned(4))
        wait_state_start = 0
        wait_states <<= Reg(
            Select(
                wait_state_start,
                Select(
                    wait_states == 0,
                    decrement(wait_states),
                    0
                ),
                req_wait_states
            )
        )

        self.event_bus_idle <<= (state == BusIfStates.idle) & (next_state == BusIfStates.idle)

        dram_wait = ~self.dram.n_wait
        dram_wait_i1 = Reg(dram_wait, clk_port=~self.clk)
        dram_wait_i2 = Reg(dram_wait_i1)

        # Address space slicing and dicing
        req_da  = req.addr[25:22] # address presented on data pins during RAS cycle
        req_mms = req.addr[26]
        req_ra  = Select( # row address
            req_mms | (req.request_type == RequestTypes.refresh),
            req.addr[21:11],
            concat(req.addr[21], req.addr[19], req.addr[17], req.addr[16], req.addr[13:7])
        )
        req_ca  = Select( # col address
            req_mms,
            req.addr[10:0],
            concat(req.addr[20], req.addr[18], req.addr[16], req.addr[14], req.addr[6:0])
        )
        req_dbs = Select(
            dram_bank_size,
            req.addr[14],
            req.addr[16],
            req.addr[18],
            req.addr[20],
            req.addr[22],
            req.addr[22],
            req.addr[22],
            req.addr[22]
        )
        req_page = req.addr[6:0]
        prev_page = Reg(req_page, clock_en = req_progress)
        break_burst = req_page != prev_page
        req_space = Wire(EnumNet(MemSpaces))
        req_space <<= Select(
            req_mms,
            MemSpaces.nren,
            Select(req_dbs, MemSpaces.dram_0, MemSpaces.dram_1),
        )
        ras_wait = SelectOne(
            req_space == MemSpaces.dram_0, dram_0_wait,
            req_space == MemSpaces.dram_1, dram_1_wait,
            req_space == MemSpaces.nren,   nren_wait
        )
        req_ras_a = (req_mms & (req_dbs == dram_bank_swap)) | (req.req_type == RequestTypes.refresh)
        req_ras_b = (req_mms & (req_dbs != dram_bank_swap)) | (req.req_type == RequestTypes.refresh)
        req_nren  = ~req_mms


        self.fsm.add_transition(BusIfStates.idle,                         ~req.valid &  dram_wait_i2,                        BusIfStates.idle)
        self.fsm.add_transition(BusIfStates.idle,                          req.valid &  dram_wait_i2,                        BusIfStates.idle)
        self.fsm.add_transition(BusIfStates.idle,                          req.valid & ~dram_wait_i2,                        BusIfStates.ras_cas0)
        self.fsm.add_transition(BusIfStates.ras_cas0,                      req.valid & ~dram_wait_i2 & ~break_burst,         BusIfStates.cas1_cas0)
        self.fsm.add_transition(BusIfStates.ras_cas0,                      req.valid & ~dram_wait_i2 &  break_burst,         BusIfStates.cas1_ras)
        self.fsm.add_transition(BusIfStates.ras_cas0,                     ~req.valid,                                        BusIfStates.cas1_ras)
        self.fsm.add_transition(BusIfStates.cas1_cas0,                     req.valid & ~dram_wait_i2 & ~break_burst,         BusIfStates.cas1_cas0)
        self.fsm.add_transition(BusIfStates.cas1_cas0,                     req.valid & ~dram_wait_i2 &  break_burst,         BusIfStates.cas1_ras)
        self.fsm.add_transition(BusIfStates.cas1_cas0,                    ~req.valid,                                        BusIfStates.cas1_ras)
        self.fsm.add_transition(BusIfStates.cas1_ras,                      1,                                                BusIfStates.idle)

        def decode_state(state, **kwargs):
            # This is a neat trick, I think: argument names are matched to enum values
            for possible_state in BusIfStates:
                if possible_state.name not in kwargs.keys():
                    raise SyntaxErrorException(f"Incomplete encoding. State '{possible_state.name}' is not listed")

            selectors = []
            for name, value in kwargs.items():
                try:
                    selectors.append((state == BusIfStates[name]), value)
                except KeyError:
                    raise SyntaxErrorException(f"Unknown state '{name}' is requested")

            return SelectOne(*selectors)

        # 'f' postfix stands for the first half of the clock
        # 's' postfix stands for the second half of the clock
        ras_f = decode_state(state,
            idle                 = 0,
            ras_cas0             = 1,
            cas0_cas1            = 1,
            cas1_cas0            = 1,
            cas1_none            = 1,
            ras_wait             = 1,
            ras_ras              = 1,
            cas0_ras             = 1,
            cas1_ras             = 1,
            cas0_cas0            = 1,
            ras_cas1             = 1,
            cas1_cas1            = 1,
        )
        ras_s = decode_state(state,
            idle                 = 0,
            ras_cas0             = 1,
            cas0_cas1            = 1,
            cas1_cas0            = 1,
            cas1_none            = 0,
            ras_wait             = 1,
            ras_ras              = 1,
            cas0_ras             = 1,
            cas1_ras             = 1,
            cas0_cas0            = 1,
            ras_cas1             = 1,
            cas1_cas1            = 1,
        )
        cas0_f = decode_state(state,
            idle                 = 0,
            ras_cas0             = 0,
            cas0_cas1            = 1,
            cas1_cas0            = 0,
            cas1_none            = 0,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 1,
            cas1_ras             = 0,
            cas0_cas0            = 1,
            ras_cas1             = 0,
            cas1_cas1            = 0,
        )
        cas0_s = decode_state(state,
            idle                 = 0,
            ras_cas0             = 1,
            cas0_cas1            = 0,
            cas1_cas0            = 1,
            cas1_none            = 0,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 0,
            cas1_ras             = 0,
            cas0_cas0            = 1,
            ras_cas1             = 0,
            cas1_cas1            = 0,
        )
        cas1_f = decode_state(state,
            idle                 = 0,
            ras_cas0             = 0,
            cas0_cas1            = 0,
            cas1_cas0            = 1,
            cas1_none            = 1,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 0,
            cas1_ras             = 1,
            cas0_cas0            = 0,
            ras_cas1             = 0,
            cas1_cas1            = 1,
        )
        cas1_s = decode_state(state,
            idle                 = 0,
            ras_cas0             = 0,
            cas0_cas1            = 1,
            cas1_cas0            = 0,
            cas1_none            = 0,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 0,
            cas1_ras             = 0,
            cas0_cas0            = 0,
            ras_cas1             = 1,
            cas1_cas1            = 1,
        )
        addr_col_sel_f = decode_state(state,
            idle                 = 0,
            ras_cas0             = 0,
            cas0_cas1            = 1,
            cas1_cas0            = 1,
            cas1_none            = 1,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 1,
            cas1_ras             = 1,
            cas0_cas0            = 1,
            ras_cas1             = 0,
            cas1_cas1            = 1,
        )
        addr_col_sel_s = decode_state(state,
            idle                 = 0,
            ras_cas0             = 1,
            cas0_cas1            = 1,
            cas1_cas0            = 1,
            cas1_none            = 0,
            ras_wait             = 0,
            ras_ras              = 0,
            cas0_ras             = 1,
            cas1_ras             = 1,
            cas0_cas0            = 1,
            ras_cas1             = 1,
            cas1_cas1            = 1,
        )

        ras = Select(self.clk, ras_s, ras_f)
        self.dram.n_ras_a        <<= ~Select(req_ras_a, 0, ras)
        self.dram.n_ras_b        <<= ~Select(req_ras_b, 0, ras)
        self.dram.n_cas_0        <<= ~Select(self.clk, cas0_s, cas0_f)
        self.dram.n_cas_1        <<= ~Select(self.clk, cas1_s, cas1_f)
        self.dram.addr           <<=  Select(self.clk, addr_col_sel_s, addr_col_sel_f)
        self.dram.n_we           <<=  Select(ras, 1, req.read_not_write)
        #self.dram.data_in
        #self.dram.data_out
        #self.dram.data_out_en
        self.dram.n_nren         <<= ~Select(req_nren, 0, ras)
        #self.dram.n_wait
        #self.dram.n_dack
        #self.dram.tc
        #self.dram.bus_en


        read_active = Wire()
        read_active <<= (
            (state == BusIfStates.first) |
            (state == BusIfStates.middle) |
            ((state == BusIfStates.dma_wait) & ~waiting) |
            ((state == BusIfStates.non_dram_wait) & ~waiting & ~two_cycle_nram_access) |
            ((state == BusIfStates.non_dram_dual_wait) & ~waiting)
        ) & read_not_write
        data_in_low = Wire()
        data_in_low <<= Reg(self.dram.data_in, clock_en=(
            (state == BusIfStates.non_dram_wait) |
            (state == BusIfStates.first) |
            (state == BusIfStates.middle)
        ))

        ndram_data_in_high = Reg(self.dram.data_in, clock_en=(state == BusIfStates.non_dram_dual_wait))
        data_in_high = Select(
            nram_access,
            NegReg(self.dram.data_in),
            Select(two_cycle_nram_access, data_in_low, ndram_data_in_high)
        )

        resp_data = Wire()
        resp_data <<= Reg(Select(
            byte_en,
            None, # Invalid
            concat("8'b0", data_in_low), # 8-bit read from low-byte
            concat("8'b0", data_in_high), # 8-bit read from high-byte
            concat(data_in_high, data_in_low) # 16-bit read
        ))

        self.mem_response.valid <<= Reg(Reg(read_active & (arb_port_select == Ports.mem_port)))
        self.fetch_response.valid <<= Reg(Reg(read_active & (arb_port_select == Ports.fetch_port)))
        self.dma_response.valid <<= (state == BusIfStates.dma_wait) & ~waiting
        self.mem_response.data <<= resp_data
        self.fetch_response.data <<= resp_data


def gen():
    def top():
        class BusIfWrapperDmaRequestIf(ReadyValid):
            read_not_write  = logic
            one_hot_channel = Unsigned(4)
            byte_en         = Unsigned(2)
            addr            = BrewBusAddr
            is_master       = logic
            terminal_count  = logic

        class BusIfWrapper(Module):
            clk = ClkPort()
            rst = RstPort()

            # Interface to fetch and memory
            fetch_request  = Input(BusIfRequestIf)
            fetch_response = Output(BusIfResponseIf)
            mem_request  = Input(BusIfRequestIf)
            mem_response = Output(BusIfResponseIf)
            dma_request = Input(BusIfWrapperDmaRequestIf)
            dma_response = Output(BusIfDmaResponseIf)

            # CRS interface for config registers
            reg_if = Input(ApbIf(BrewCsrData, Unsigned(4)))

            # DRAM interface
            dram = Output(ExternalBusIf)

            # Events
            event_bus_idle = Output(logic)

            def body(self):
                bus_if = BusIf()
                bus_if.fetch_request <<= self.fetch_request
                self.fetch_response <<= bus_if.fetch_response

                bus_if.mem_request <<= self.mem_request
                self.mem_response <<= bus_if.mem_response

                bus_if.dma_request.read_not_write <<= self.dma_request.read_not_write
                bus_if.dma_request.one_hot_channel <<= self.dma_request.one_hot_channel
                bus_if.dma_request.byte_en <<= self.dma_request.byte_en
                bus_if.dma_request.addr <<= self.dma_request.addr
                bus_if.dma_request.is_master <<= self.dma_request.is_master
                bus_if.dma_request.terminal_count <<= self.dma_request.terminal_count
                bus_if.dma_request.valid <<= self.dma_request.valid
                self.dma_request.ready <<= bus_if.dma_request.ready
                self.dma_response <<= bus_if.dma_response
                bus_if.reg_if <<= self.reg_if
                self.dram <<= bus_if.dram
                self.event_bus_idle <<= bus_if.event_bus_idle

        #return ScanWrapper(BusIf, {"clk", "rst"})
        return BusIfWrapper()

    netlist = Build.generate_rtl(top, "synth/bus_if.sv")
    top_level_name = netlist.get_module_class_name(netlist.top_level)
    flow = QuartusFlow(
        target_dir="synth/q_bus_if",
        top_level=top_level_name,
        source_files=("synth/bus_if.sv",),
        clocks=(("clk", 10),),# ("top_clk", 100)),
        project_name="bus_if",
        no_timing_report_clocks="clk",
        family="MAX 10",
        device="10M50DAF672C7G" # Something large with a ton of pins
    )
    flow.generate()
    flow.run()


if __name__ == "__main__":
    gen()

