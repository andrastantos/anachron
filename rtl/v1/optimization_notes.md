Previous Stats
==========================

Flow Status	Successful - Fri Jan 27 19:48:34 2023
Quartus Prime Version	21.1.1 Build 850 06/23/2022 SJ Lite Edition
Revision Name	pipeline
Top-level Entity Name	Pipeline
Family	MAX 10
Device	10M04SAE144A7G
Timing Models	Final
Total logic elements	2,943 / 4,032 ( 73 % )
Total registers	759
Total pins	53 / 101 ( 52 % )
Total virtual pins	0
Total memory bits	1,024 / 193,536 ( < 1 % )
Embedded Multiplier 9-bit elements	6 / 40 ( 15 % )
Total PLLs	0 / 1 ( 0 % )
UFM blocks	0 / 1 ( 0 % )
ADC blocks	0 / 1 ( 0 % )

60.36MHz

Current Stats
===============================

Flow Status	Successful - Sat Feb  4 21:04:08 2023
Quartus Prime Version	21.1.1 Build 850 06/23/2022 SJ Lite Edition
Revision Name	pipeline
Top-level Entity Name	Pipeline
Family	MAX 10
Device	10M04SAE144A7G
Timing Models	Final
Total logic elements	2,846 / 4,032 ( 71 % )
Total registers	736
Total pins	39 / 101 ( 39 % )
Total virtual pins	0
Total memory bits	1,296 / 193,536 ( < 1 % )
Embedded Multiplier 9-bit elements	6 / 40 ( 15 % )
Total PLLs	0 / 1 ( 0 % )
UFM blocks	0 / 1 ( 0 % )
ADC blocks	0 / 1 ( 0 % )

58.48MHz

Speed-up tests:
=================

1. Remove mem_av: this seems to be the most critical path. At least I think that's what it is.
2. Removed multiplier, which - even with DSP blocks seems to be rather slow
3. After these, it seems that most violations are around the DDR nature of the memory controller.
   Of course, I'm trying to close timing on that for 5ns (200MHz), which is quite tight on a MAX10.
4. I think one of the problems is the bypass path auto-generated by Quartus. This is an extra 2.4ns.
5. Now the double-add in execute (to compute physical memory addresses) seems to be the problem.
   not to mention that that was incorrect there: we would only need to add the offset in TASK mode!
6. I managed to get the CAS generation down to a single LUT. Still timing doesn't close as just the I/O
   buffer alone adds about 5ns of latency. In reality though, there is no need for these signals to
   have any timing relationship with the clock, certainly not for these experiments. Yes, the capturing
   of data happens on the clock-edge, and in that sense it's needed to be in sync, but that only applies
   to the actual clock rate of ~10MHz. For that, we're clearly good.
7. Now that I've removed I/O timing constraints, the timing closure got lifted to 76MHz.
   The critical path is still in 'execute', this time it's the shift register. However, a bunch of other
   paths are soon after it, so really, I think the problem is the large selection mux at the end of execute.
   I think there's an interesting idea here: in reality we have an extra cycle for execute, if we wanted to:
   right now we're wasting it in memory. Really, the moral of the story is that we should have execute and
   memory in parallel instead of serial. Just for kicks, what if I insert a reg in exec?
8. We're at the same spot, in fact a little lower: 74MHz. Similar problems, except now on some other output
   to memory.

Comparison
==========

According  to http://downloads.aries-embedded.de/products/Spiderboard/riscv-on-max10-userguide.pdf, most RiscV implementations are around the same size, though quite a bit faster.

RAM behavior
============

Quartus complains that RAMs implement read-new-data behavior (which they do, now that I look at the RTL) and that it needs to insert a bypass pass.
This is sometihng that I should either turn off or make controllable in Silicon.

Report before RAM change

Flow Status	Successful - Sun Feb  5 11:18:46 2023
Quartus Prime Version	21.1.1 Build 850 06/23/2022 SJ Lite Edition
Revision Name	pipeline
Top-level Entity Name	Pipeline
Family	MAX 10
Device	10M04SAE144A7G
Timing Models	Final
Total logic elements	2,869 / 4,032 ( 71 % )
Total registers	805
Total pins	39 / 101 ( 39 % )
Total virtual pins	0
Total memory bits	1,296 / 193,536 ( < 1 % )
Embedded Multiplier 9-bit elements	0 / 40 ( 0 % )
Total PLLs	0 / 1 ( 0 % )
UFM blocks	0 / 1 ( 0 % )
ADC blocks	0 / 1 ( 0 % )

53.8MHz

After: 55.93MHz. Not a ton of change. Of course, this is limited by the DRAM interface at this point

Second set
==========

So, after rewriting Memory, Execute and Decode, all individual modules close timing at 100+MHz.

Yet, after putting them together, I only get up to ~85MHz. Some of the issues are around the multipliers, so I quickly removed them from the design.

Most of the critical paths seem to be around the interactions between decode and the register file.
That is to say, the reservation logic. Almost all of these paths involve either fetch or decode as well (forward and backward handshake),
but seeing both directions being problematic, I think the root is the register file and its reservation logic. One example:

;   3.439  ;   0.588 ; FF ; IC   ; 1      ; LCCOMB_X17_Y7_N16  ; decode_stage|Equal20~10|dataa                                    ;
;   3.877  ;   0.438 ; FR ; CELL ; 36     ; LCCOMB_X17_Y7_N16  ; decode_stage|Equal20~10|combout                                  ;
;   4.787  ;   0.910 ; RR ; IC   ; 1      ; LCCOMB_X18_Y8_N8   ; decode_stage|branch_op~6|datad                                   ;
;   4.954  ;   0.167 ; RR ; CELL ; 8      ; LCCOMB_X18_Y8_N8   ; decode_stage|branch_op~6|combout                                 ;
;   5.274  ;   0.320 ; RR ; IC   ; 1      ; LCCOMB_X18_Y8_N12  ; reg_file|read2_addr[1]~0|datab                                   ;
;   5.758  ;   0.484 ; RF ; CELL ; 3      ; LCCOMB_X18_Y8_N12  ; reg_file|read2_addr[1]~0|combout                                 ;
;   6.829  ;   1.071 ; FF ; IC   ; 1      ; LCCOMB_X19_Y7_N6   ; reg_file|read2_addr[1]~1|datad                                   ;
;   6.963  ;   0.134 ; FF ; CELL ; 1      ; LCCOMB_X19_Y7_N6   ; reg_file|read2_addr[1]~1|combout                                 ;
;   7.697  ;   0.734 ; FF ; IC   ; 1      ; LCCOMB_X15_Y7_N0   ; reg_file|read2_addr[1]~5|datab                                   ;
;   8.158  ;   0.461 ; FF ; CELL ; 5      ; LCCOMB_X15_Y7_N0   ; reg_file|read2_addr[1]~5|combout                                 ;
;   8.450  ;   0.292 ; FF ; IC   ; 1      ; LCCOMB_X15_Y7_N6   ; reg_file|read2_addr[1]~6|datad                                   ;
;   8.615  ;   0.165 ; FR ; CELL ; 6      ; LCCOMB_X15_Y7_N6   ; reg_file|read2_addr[1]~6|combout                                 ;
;   9.532  ;   0.917 ; RR ; IC   ; 1      ; LCCOMB_X15_Y11_N28 ; reg_file|read2_addr[3]~12|datac                                  ;
;   9.840  ;   0.308 ; RR ; CELL ; 1      ; LCCOMB_X15_Y11_N28 ; reg_file|read2_addr[3]~12|combout                                ;
;   10.073 ;   0.233 ; RR ; IC   ; 1      ; LCCOMB_X15_Y11_N10 ; reg_file|read2_addr[3]~13|datad                                  ;
;   10.240 ;   0.167 ; RR ; CELL ; 4      ; LCCOMB_X15_Y11_N10 ; reg_file|read2_addr[3]~13|combout                                ;
;   11.172 ;   0.932 ; RR ; IC   ; 1      ; LCCOMB_X16_Y9_N2   ; reg_file|read2_rsv_bit~6|dataa                                   ;
;   11.644 ;   0.472 ; RF ; CELL ; 1      ; LCCOMB_X16_Y9_N2   ; reg_file|read2_rsv_bit~6|combout                                 ;
;   11.903 ;   0.259 ; FF ; IC   ; 1      ; LCCOMB_X16_Y9_N0   ; reg_file|read2_rsv_bit~9|datad                                   ;
;   12.037 ;   0.134 ; FF ; CELL ; 1      ; LCCOMB_X16_Y9_N0   ; reg_file|read2_rsv_bit~9|combout                                 ;
;   12.300 ;   0.263 ; FF ; IC   ; 1      ; LCCOMB_X16_Y9_N30  ; reg_file|wait_for_write~1|datad                                  ;
;   12.434 ;   0.134 ; FF ; CELL ; 2      ; LCCOMB_X16_Y9_N30  ; reg_file|wait_for_write~1|combout                                ;
;   12.774 ;   0.340 ; FF ; IC   ; 1      ; LCCOMB_X16_Y9_N16  ; reg_file|rsv_set_valid|dataa                                     ;
;   13.234 ;   0.460 ; FR ; CELL ; 9      ; LCCOMB_X16_Y9_N16  ; reg_file|rsv_set_valid|combout                                   ;
;   14.045 ;   0.811 ; RR ; IC   ; 1      ; LCCOMB_X19_Y9_N0   ; reg_file|Equal48~1|datad                                         ;
;   14.212 ;   0.167 ; RR ; CELL ; 2      ; LCCOMB_X19_Y9_N0   ; reg_file|Equal48~1|combout                                       ;
;   14.454 ;   0.242 ; RR ; IC   ; 1      ; LCCOMB_X19_Y9_N24  ; reg_file|u131_output_port~2|datad                                ;
;   14.621 ;   0.167 ; RR ; CELL ; 1      ; LCCOMB_X19_Y9_N24  ; reg_file|u131_output_port~2|combout                              ;
;   14.621 ;   0.000 ; RR ; IC   ; 1      ; FF_X19_Y9_N25      ; reg_file|u131_output_port|d                                      ;

Granted, this is not the whole path, but just reg path within reg_file is close to 10ns. So, we need to attack this somehow.

Step 1
--------
I've re-written the 'Select' primitive to generate outlined statements (cases) to help the synthesizer.

That didn't help at all. It made the RTL nicer, but the synthesizer couldn't care less. I guess, no surprise there,
it still describes the same logic. As a side-benefit, now 'Select' support default_ports, because it can.

I think I'll also have to rewrite SelectOne as well.

      Side-note:
      Major revelation: both the 68000 and the 8086 were initially offered at around 5MHz clock rates. The later versions were around 10MHz, but those most likely were die-shrunk to 2u or even 1.5u flows. So no wonder I have trouble closing timing at 250 (or even 100) MHz. Here's the list for the 8086:

         Model number 	Frequency 	Technology 	Temperature range 	Package 	Date of release 	Price (USD)[list2 1]
         8086 	5 MHz[12] 	HMOS 	0 °C to 70 °C[13] 		June 8, 1978[14] 	$86.65[15]
         8086-1 	10 MHz 	HMOS II 	Commercial
         8086-2 	8 MHz[12] 	HMOS II 	Commercial 		January/February 1980[16] 	$200[16][17]
         8086-4 	4 MHz[12] 	HMOS 	Commercial 			$72.50[list2 2][18]
         I8086 	5 MHz 	HMOS 	Industrial −40 °C to +85 °C[13] 		May/June 1980[13] 	$173.25[13]
         M8086 	5 MHz 	HMOS 	Military grade −55 °C to +125 °C[19]
         80C86[20] 		CMOS 		44 Pin PLCC[list2 3][21]

      So, yeah, HMOS maxed out at 5MHz. I think I'll have to give myself HMOS II

      All processors (80286, ported version of 8086, 68000 68020, R2000) ran at around 10MHz and the ones specifically designed for this node were around 110000 transistors.

      Soo.... should I allow myself that luxury? It certainly makes it easier: I would only need to close to about 150MHz and I can have 0.3mm^2 area according to Denard scaling (and that the R2000 was 80mm^2). The 68020 was about 200000 transistors...

Back to decode...

So, just for kicks, I'm trying to register the selectors. That is a horrible idea if the synthesizer is dumb: we remove all opportunity
to optimize the selectors. However, if the synthesizer is smart and moves the registers around, it might turn out to be a great idea. Yeah, it made it worse...

So, the next thing is try to clean up the selectors: after all, we know if the selected field is the same, so we can group...

F8ck! So, it turns out the RTL for *all* SelectOne and Select statements were wrong. Or at least for all with more than 2 selectors.
The operator precedence was incorrect. Now I'm re-running decode, but all bets are off at this point...

So, the good news is that the clock frequency didn't degrade. The bad news is that it didn't really improve either (that much). We went from 112 to 116MHz.

Step 2
------

So now, that selectors actually ... select, I re-run the whole pipeline. It still closes timing to only about 85MHz, but the failing paths are now showing up in the mem_av circuitry.

So, that's pretty sad if we can't fit a 32-bit adder and a 22-bit magnitude comparator into a single 100MHz cycle... That'll byte me in load-store address calculations a lot.

I'll just put a reg in there and retry, just for kicks. That of course is not right (TM).

That helped in that we're back to the RF being the problem.

Step 3
------

So, now, I'm adding registers into the RF. Of course this is now completely borken, but I need to know what to fix before I can fix it...

Now we're talking!!!! 99.13MHz with a single failing path.

But that's a tough nut to break: this is the 32-bit adder inside the ALU. Since this *isn't* the only 32-bit adder, it tells me that we're on the hairy edge for anything like that.

Step 4
------

So, now, I'm changing to commercial parts and lower the max temp to +85C (from +125C and an automotive part). I'm also lifting the lower end from -40C to 0C. I kept the -7 (mid-range) part though.

And that ladies and gentlemen made it: 102MHz!!!!

Now, if only this would actually be functional...

Learnings
=========

- A 32-bit adder in a MAX10 is border-line too big to close timing at a 100MHz
- Two large-ish adders certainly don't fit (LoadStoreUnit)
- Muxes to select from registers are also problematic (RegFile)
- The optimizer is relatively good at finding optimal logic, or at least describing the same logic in alternate forms doesn't really impress it one way or another.
- Larger designs are slower, potentially significantly then it's components. That's especially true for signals crossing unit-boundaries. This can probably be mitigated somewhat by religiously registering every signal on component boundaries.

Now, let's see what OpenSilicon thinks about the same verilog...
