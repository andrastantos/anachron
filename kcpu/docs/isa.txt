ISA
=============================================
There are a few ideas to explore in this processor design:

- We have 15 addressable registers, instead of 16. This allows us to use the 16th code (0xf) to be used as an
  escape to gain all sorts of compact, yet easy to decode spaces in the instruction code
- We have two execution contexts: one, called TASK mode, the other, called SCHEDULER mode
- We don't have interrupt enable/disable instructions. Instead, in TASK mode interrupts are always enabled
  while in SCHEDULER mode interrupts are always disabled
  This means that the processor should spend very little time in SCHEDULER mode, essentially just as much
  as it needs to figure out what to do next, and tee up the appropriate task to handle the situation.
  This is where the naming of the two contexts are coming from: SCHEDULER mode is used for - essentially -
  task switching only, and all useful work (including OS functionality) happens in various TASK contexts.
- Each context has it's own program counter (TPC and SPC).
- Switcing between contexts happens using interrupts (TASK -> SCHEDULER), exceptions (TASK -> SCHEDULER)
  and instructions (switches either way).
- Every instruction can be executed with the exact same semantics in both TASK and SCHEDULER mode. Protection
  is achieved by two key concepts:
  - There is a slight imbalance in the ISA: there is a way to influence the current contexts' PC and
    TPC, there is no way to influence SPC (unless of course that happens to be the current context PC)
  - All resources (I/O, memory, even CSRs) are accessed through memory references. These references go through
    an MMU, which controls per-task access rights. This way OS tasks can have higher access to system resources
    then user code. SCHEDULER mode accesses also go through the MMU, but use a different page table address.
    The switch between TASK and SCHEDULER mode MMU page tables is automatic, so when SCHEDULER mode gains
    back execution, it's not limited to the access rights of the last executed task.
- There is no interrupt or exception vector. Instead, when TASK mode execution gets interrupted, SCHEDULER
  mode execution continues from the current SPC. Since the only way to return from SCHEDULER mode to TASK mode
  is by the use of the STU instruction, this means that after an interrupt or exception, executing continues
  in SCHEDULER mode after this STU instruction. SCHEDULER mode code needs to be written as an endless loop,
  where STU can be thought of as a procedure call.
- The ISA strictly operates on the 2-read;1-write port register file principle. This means no PUSH/PULL primitives
  (as PULL would require two writes into the register file).
- The ISA doesn't have CALL/RETURN primitives either (again, return would require two writes).

INSTRUCTION ENCODING
=============================================

There are two encoding variants:

16-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

48-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |  |                                                            FIELD_I                                                            |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

FIELD_C normally contains the instruction op-code
FIELD_B normally contains the register index of the second operand
FIELD_A normally contains the register index of the first operand
FIELD_D normally contains the register index of the destination
FIELD_I normally contains an immediate or a memory offset

The whole 16 bit instruction is referred to as the INST.
The '[]' operator represents sub-fields in verilog notation.
The '{}' operator represents concatenation in verilog notation.
The ':' operator represents range (when that context make sense)

Each of fields C,B,A,D can be 0xf or some other value. This gives us 16 instruction groups. These groups are named by the fields which are not 0xf.
So, for instance group BA would be a group where both FIELD_C and FIELD_D are 0xf, while neither FIELD_B and FIELD_A are.

Register indexes:

0x0:  current mode PC (TPC or SPC depending on the mode0
0x1:  R1
0x2:  R2
0x3:  R3
0x4:  R4
0x5:  R5
0x6:  R6
0x7:  R7
0x8:  R8
0x9:  R9
0xa:  R_A
0xb:  R_B
0xc:  Rc
0xd:  R_D
0xe:  Re
0xf:  reserved

NOTE: PC is a 31-bit register: the LSB is ignored on write and always reads as 0.

INSTRUCTION SET
=============================================

In the following tables
- '.' means any value in [0x0:0xe], unless specifically listed as a special case.
      Can be a different number at every occurance.
- 'r': any number in [0x0:0xe] (but the same number in every occurance



ALU operations:
-------------------------------

Form A (group CBAD):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION
-----------------------------------------
0x0...             XOR       R_D = R_A xor R_B    *special cases:
0x0000             FILL      enters privileged mode, disables interrupts - used to fill unused code-pages; TPC points to the next instruction
0x0110             BREAK     enters privileged mode, disables interrupts - used for SW breakpoints; TPC points to the next instruction
0x0220             SYSCALL   enters privileged mode, disables interrupts - used for SYSCALL-s; TPC points to the next instruction
0x0330             STU       enters user mode, enables interrupts; SPC points to the next instruction
0x0440:0x0cc0      SII
0x0dd0             FENCE     ensures that all memory references are completed before continuing
0x0ee0             WFENCE    ensures the write queue is fully flushed before continuing
0x1...             OR        R_D = R_A or R_B    **special cases:
0x1000             WOI       Wake on interrupt (program visible behavior is the same as PC=PC or PC, can apply power saving)
0x2...             AND       R_D = R_A and R_B    ***special cases:
0x2rr.             BSWAP     R_D = {R_r[7:0], R_r[15:8], R_r[23:16], R_r[31:24]} (this would be a MOVE, which can be achieved through R_D = R_A or R_A)
0x3...             SUB       R_D = R_A - R_B      ****special cases:
0x3rr.             WSWAP     R_D = {R_r[15:0], R_r[31:16]} (this would be a set register to zero op, which can be achieved through R_D = R_A xor R_A)
0x4...             ADD       R_D = R_A + R_B
0x5...             SHL       R_D = R_A shl R_B
0x6...             SHR       R_D = R_A shr R_B
0x7...             SAR       R_D = R_A sar R_B
0x8...             MULS      R_D = R_A * R_B lower (signed)     #special cases:
0x80..             TMOV      R_D = R_A, but A and D references TPC instead of PC, when set to 0.
0x9...             MUL       R_D = R_A * R_B lower (unsigned)   ##special cases:
0x90..             INC       R_D = R_A + 1
0x9.0.             DEC       R_D = R_B - 1
0x900.             SII
0xa...             XMULS     R_D = R_A * R_B upper (signed)     ###special cases:
0xa0..             NEG       R_D = -R_A (neg)
0xa.0.             NOT       R_D = ~R_B (not)
0xa00.             SII
0xb...             XMUL      R_D = R_A * R_B upper (unsigned)   ####special cases:
0xb0..             SII
0xb.0.             SII
0xb00.             SII


Form B (group CBD):
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE   OPERATION
-----------------------------------------
0x0.f.        XOR       R_D = R_B xor VALUE
0x1.f.        OR        R_D = R_B or VALUE
0x2.f.        AND       R_D = R_B and VALUE
0x3.f.        SUB       R_D = R_B - VALUE
0x4.f.        ADD       R_D = R_B + VALUE
0x5.f.        SHL       R_D = R_B shl VALUE
0x6.f.        SHR       R_D = R_B shr VALUE
0x7.f.        SAR       R_D = R_B sar VALUE
0x8.f.        MULS      R_D = R_B * VALUE lower (signed
0x9.f.        MUL       R_D = R_B * VALUE lower (unsigned)
0xa.f.        XMULS     R_D = R_B * VALUE upper (signed)
0xb.f.        XMUL      R_D = R_B * VALUE upper (unsigned)

Form C (group CAD):
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE   OPERATION
-----------------------------------------
0x0f..        SII       invalid instruction exception
0x1f..        SII       invalid instruction exception
0x2f..        SII       invalid instruction exception
0x3f..        SUB       R_D = VALUE - R_A
0x4f..        SII       invalid instruction exception
0x5f..        SHL       R_D = VALUE shl R_A
0x6f..        SHR       R_D = VALUE shr R_A
0x7f..        SAR       R_D = VALUE sar R_A
0x8f..        SII       invalid instruction exception
0x9f..        SII       invalid instruction exception
0xaf..        SII       invalid instruction exception
0xbf..        SII       invalid instruction exception


NOTE: there are a number of combinations that don't make sense:
    - R_A xor R_B with PC as target
    - R_A and R_B where A == B (that is a move, which can be accompished by or)
    - R_A - R_B where A == B (that's zero, which can be accompished by xor)
    - R_A*R_B with A == 0 or B == 0 (PC)
    - shl, shr, sar with B == 0 (PC)
    - or, and, xor, + * in form C (these are symmetrical operations, so form B is sufficiant)
    There might be others as well.
    Many of these combinations are used as holes to sneak in a few odd-ball instructions
    that otherwise would eat up encoding space. This complicates instruction decode, but
    hopefully not by much: in most cases, both the base and the alternate operation
    can procede, and selected upon write-back (giving us at least one extra decode cycle).

NOTE: there are no 8- or 16-bit variants of these instructions. Use 0- or sign-extend during loads to achive type-conversion.
NOTE: encoding is such that OP-code 0 is FILL

Branches:
-------------------------------

Form A (group CBA):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE   OPERATION
-------------------------------
0x0..f        BEQ       if R_A == R_B              then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x1..f        BNE       if R_A != R_B              then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x2..f        BGTS      if R_A > R_B (signed)      then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x3..f        BLES      if R_A <= R_B (signed)     then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x4..f        BGT       if R_A > R_B (unsigned)    then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x5..f        BLT       if R_A <= R_B (unsigned)   then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.0f        BEQZ      if R_B == 0                then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.1f        BNEZ      if R_B != 0                then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.2f        BLTZS     if R_B < 0 (signed)        then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.3f        BGEZS     if R_B >= 0 (signed)       then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.4f        BGTZS     if R_B > 0 (signed)        then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.5f        BLEZS     if R_B <= 0 (signed)       then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x7..f        SII
0x8..f        SII
0x9..f        SII
0xa..f        SII
0xb..f        SII
0xc..f        SII
0xd..f        SII
0xe..f        SII

NOTE: there are a lot of pseudo-op-codes that can be created here. For instance:
      - unconditional branch (B) is possible with OP=0, A = B
      - branch if less-than (BLT and BLTS) can be achieved by BGT and BGTS and swapping A and B fields
      - branch if greater-than-equal (BGTE and BGTES) can be achieved by BLTE and BLTES and swapping A and B fields
      - branch if unsigned greater than zero (BGTZ) is the same as BNEZ
      - branch if unsigned less then or equal to zero (BLEZ) BEQZ

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

Form B (group CA):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE   OPERATION
-------------------------------
0x0f.f        BBS       if R_A[0] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x1f.f        BBS       if R_A[1] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x2f.f        BBS       if R_A[2] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x3f.f        BBS       if R_A[3] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x4f.f        BBS       if R_A[4] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x5f.f        BBS       if R_A[5] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6f.f        BBS       if R_A[6] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x7f.f        BBS       if R_A[7] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x8f.f        BBS       if R_A[8] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x9f.f        BBS       if R_A[9] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xaf.f        BBS       if R_A[a] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xbf.f        BBS       if R_A[b] == 1 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xcf.f        SII
0xdf.f        SII
0xef.f        SII

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

Form C (group CB):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE   OPERATION
-------------------------------
0x0.ff        BBC       if R_B[0] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x1.ff        BBC       if R_B[1] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x2.ff        BBC       if R_B[2] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x3.ff        BBC       if R_B[3] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x4.ff        BBC       if R_B[4] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x5.ff        BBC       if R_B[5] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x6.ff        BBC       if R_B[6] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x7.ff        BBC       if R_B[7] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x8.ff        BBC       if R_B[8] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0x9.ff        BBC       if R_B[9] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xa.ff        BBC       if R_B[a] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xb.ff        BBC       if R_B[b] == 0 then PC = R ? PC + {OFFSET,0} : {OFFSET,0}
0xc.ff        SII
0xd.ff        SII
0xe.ff        SII

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

NOTE: over- and under-flows wrap during relative address calculations.
NOTE: in the branch predictor, relative jumps with negative OFFSET VALUE can be assumed to be taken by default. Compilers are encouraged to encode back-edges of loops in this encoding to improve
      branch prediction.

Load/Store
----------

Form A (parts of group BAD): Load/store R_D from [R_B]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |    SOP    |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE   OPERATION
-------------------------------
0xf0..        LDSB      8-bit signed load from MEM[R_A] into R_D
0xf1..        LDB       8-bit unsigned load from MEM[R_A] into R_D
0xf2..        LDSW      16-bit signed load from MEM[R_A] into R_D
0xf3..        LDW       16-bit unsigned load from MEM[R_A] into R_D
0xf4..        LD        32-bit load from MEM[R_A] into R_D
0xf5..        STB       8-bit store to MEM[R_A] from R_D
0xf6..        STW       16-bit store to MEM[R_A] from R_D
0xf7..        SW        32-bit store to MEM[R_A] from R_D

NOTE: op-codes with D=0xf have confusing decode: on the one hand, they would logically mean load/store from MEM[R_A] to TPC. On the other, since the D field is 0xf, they would
      signal a 48-bit instruction. To resolve this problem - and leave instruction length decode simple - these operations generate an SII

Form B (parts of group BD and group B): Load R_D with VALUE (load immediate)

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |    SOP    | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE   OPERATION
-------------------------------
0xf0f.        SII*      8-bit signed load from VALUE into R_D
0xf0ff        SII*      8-bit signed load from VALUE into TPC
0xf1f.        SII*      8-bit unsigned load from VALUE into R_D
0xf1ff        SII*      8-bit unsigned load from VALUE into TPC
0xf2f.        SII*      16-bit signed load from VALUE into R_D
0xf2ff        SII*      16-bit signed load from VALUE into TPC
0xf3f.        SII*      16-bit unsigned load from VALUE into R_D
0xf3ff        SII*      16-bit unsigned load from VALUE into TPC
0xf4f.        LD        32-bit load from VALUE into R_D
0xf4ff        LD        32-bit load from VALUE into TPC
0xf5f.        SII**
0xf5ff        SII**
0xf6f.        SII**
0xf6ff        SII**
0xf7f.        SII**
0xf7ff        SII**

*: Sign- and zero-extending constants doesn't make sense. The OP-codes generate SII
**: Store immediate is not a 'thing'. These OP-codes generate SII


Form C (parts of group BD, group ., group D and group B): Load/store R_D from [VALUE]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 1 |    SOP    | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE   OPERATION
-------------------------------
0xf8f.        LDSB      8-bit signed load from MEM[VALUE] into R_D
0xf8ff        LDSB      8-bit signed load from MEM[VALUE] into TPC
0xf9f.        LDB       8-bit unsigned load from MEM[VALUE] into R_D
0xf9ff        LDB       8-bit unsigned load from MEM[VALUE] into TPC
0xfaf.        LDSW      16-bit signed load from MEM[VALUE] into R_D
0xfaff        LDSW      16-bit signed load from MEM[VALUE] into TPC
0xfbf.        LDW       16-bit unsigned load from MEM[VALUE] into R_D
0xfbff        LDW       16-bit unsigned load from MEM[VALUE] into TPC
0xfcf.        LD        32-bit load from MEM[VALUE] into R_D
0xfcff        LD        32-bit load from MEM[VALUE] into TPC
0xfdf.        STB       8-bit store to MEM[VALUE] from R_D
0xfdff        STB       8-bit store to MEM[VALUE] from TPC
0xfef.        STW       16-bit store to MEM[VALUE] from R_D
0xfeff        STW       16-bit store to MEM[VALUE] from TPC
0xfff.        SW        32-bit store to MEM[VALUE] from R_D
0xffff        SW        32-bit store to MEM[VALUE] from TPC


Form D (parts of group BAD, group BA, group AD and group A): Load/store R_D from [VALUE+R_B]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 1 |    SOP    |       A       |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE   OPERATION
-------------------------------
0xf8..        LDSB      8-bit signed load from MEM[R_A+VALUE] into R_D
0xf8.f        LDSB      8-bit signed load from MEM[R_A+VALUE] into TPC
0xf9..        LDB       8-bit unsigned load from MEM[R_A+VALUE] into R_D
0xf9.f        LDB       8-bit unsigned load from MEM[R_A+VALUE] into TPC
0xfa..        LDSW      16-bit signed load from MEM[R_A+VALUE] into R_D
0xfa.f        LDSW      16-bit signed load from MEM[R_A+VALUE] into TPC
0xfb..        LDW       16-bit unsigned load from MEM[R_A+VALUE] into R_D
0xfb.f        LDW       16-bit unsigned load from MEM[R_A+VALUE] into TPC
0xfc..        LD        32-bit load from MEM[R_A+VALUE] into R_D
0xfc.f        LD        32-bit load from MEM[R_A+VALUE] into TPC
0xfd..        STB       8-bit store to MEM[R_A+VALUE] from R_D
0xfd.f        STB       8-bit store to MEM[R_A+VALUE] from TPC
0xfe..        STW       16-bit store to MEM[R_A+VALUE] from R_D
0xfe.f        STW       16-bit store to MEM[R_A+VALUE] from TPC
0xff..        SW        32-bit store to MEM[R_A+VALUE] from R_D
0xff.f        SW        32-bit store to MEM[R_A+VALUE] from TPC


NOTE: form A with D==0xf is invalid to simplify instruction (length) decode. This combination generates SII
      This means that load/store TPC from register offset can only be achieved using fomr D and VALUE==0


UNUSED:
-------------------------------

parts of group BA:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |                           | 1 | 1 | 1 | 1 |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

group C:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

group CD:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |               |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+


+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 0 |                                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 1 |                                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 |                                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

These generate SII operations to allow for further expansion

INSTRUCTION GROUP SUMMARY:
==========================

group CBAD: ALU and special function
group CBD: ALU
group CAD: ALU
group CBA: conditional branch
group CB: bit test branch
group CA: bit test branch
group BAD: load/store
group BA: load/store (some reserved)
group AD: load/store
group BD: load/store
group B: load/store
group A: load/store
group D: load/store
group .: load/store
group C: reserved
group CD: reserved

DECODE NOTES:
=============

Instruction encoding is such that the following condition can be used to determine if the extra 32-bits are needed or not:
  &inst[15:11] | &inst[11:8] | &inst[7:4] | &inst[3:0]

The first read port address of the register file comes from:
  &inst[15:12] ? inst[3:0] : inst[11:8]

The second read port address of the register file comes from:
  inst[7:4]

The write port address of the register file comes from:
  inst[3:0]
  NOTE: TPC and SPC are special and needs special decoding logic: they are written by all sort of weird combos of bit-fields

Branches can be identified by:
  inst[3:0] == 0x0 | inst[3:0] == 0xf
  NOTE: this mis-identifies XMOV, WFLUSH and TPC load/stores as branches, but that's a harmless mistake.

NOTE:
========
CALLs can be implemented by:
R5 = PC+12    // calculate return address - NEW INSTRUCTION
[SP+xxx] = R5 // put return address into stack-frame - WOULD BE NEEDED ANYWAY (if link register needs saving)
SP = SP+xxx   // finalize stack-frame - WOULD BE NEEDED ANYWAY (if any arguments are passed on the stack)
PC = yyy      // jump to the subroutine - WOULD BE NEEDED ANYWAY

// return:
R5 = [SP]     // load return address - WOULD BE NEEDED ANYWAY (if link register needs saving)
SP = SP-xxx   // free stack-frame - WOULD BE NEEDED ANYWAY
PC = R5       // return - WOULD BE NEEDED ANYWAY

Notice how this is only one instructions longer than the link approach as the stack-adjustment and the save/restore of the link register
would be there in most cases anyways.

