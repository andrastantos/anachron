The following register usage is defined:

   $pc  - a.k.a. $r0 - program counter.
   $sp  - a.k.a. $r1 - stack pointer.
   $fp  - a.k.a. $r2 - frame pointer.
   $r3  - link register.
   $r4  - first argument/return value register.
   $r5  - second argument/return value register.
   $r6  - third argument/return value register; EH_RETURN_DATA_REGNO
   $r7  - fourth argument/return value register; EH_RETURN_DATA_REGNO
   $r8  - general purpose caller-saved 32-bit register; EH_RETURN_DATA_REGNO; 
   $r9  - general purpose caller-saved 32-bit register; EH_RETURN_DATA_REGNO
   $r10 - general purpose caller-saved 32-bit register; EH_RETURN_STACKADJ_RTX BREW_STACKADJ_REG
   $r11 - general purpose callee-saved 32-bit register. 
   $r12 - general purpose callee-saved 32-bit register.
   $r13 - general purpose callee-saved 32-bit register.
   $r14 - general purpose callee-saved 32-bit register; static chain register

NOTE: we should review this! We probably can get away with EH_RETURN_DATA_REGNO start from $r4.
      we probably could also get away with EH_RETURN_STACKADJ_RTX being the static chain register (what is that anyway???)
      finally, we should have the same number of caller and callee-saved registers.

FUNCTION ARGUMENTS
==================

Arguments (and return values) are passed, first in registers,
then on the stack. Stack area is reserved for all arguments
independent of their storage location.
Arguments can span multiple registers, but always start at
a register boundary. On the stack, they are also aligned
(and in cases where it makes sense promoted) to 32-bit boundaries.
It's also possible for an argument to be partially in registers
and partially on the stack.

NOTE: the only reason an argument is partially in registers is if
there isn't enough registers left to keep them in registers.
Similarly, an argument is placed on the stack only if we completely
ran out of argument-passing registers. Consequently, if an
argument is partially or fully on the stack, all subsequent arguments 
are fully on the stack.

!!! TODO: what exactly!!! Some arguments are passed by reference
no matter what. These should be 'large' or unknown sized
arguments. In those cases, a pointer to them is put on the stack
or in registers, whichever makes sense by the previous rules.

The registers used for argument passing in increasing register
index are: $r4, $r5, $r6 and $r7.

Return values are handled the same way.

SYSCALLS
========

Syscalls follow the same calling convention, except that $r3 contains
a syscall-dependent pointer (usually pointer to errno). The SYSCALL instruction
is used to transfer control to the executive. The syscall number is stored
as a 16-bit code after the SYSCALL instruction, in the instruction-stream.
(NOTE: 16-bit so we don't have alignment problems reading it). Upon entering
scheduler mode, $TPC points to the *next* instruction, which is to say, it
points to the syscall number. The scheduler needs to increment $TPC by 2
before returning execution to task mode.

STACK
=====

Stack is pre-decrement for push, and post-increment for pop.
This means that $sp points to the last valid value.
NOTE: since the stack is SW managed, pushes and pops are not
      atomic. Interrupt handlers can't assume that $sp actually
      points to the top of the stack.

Stack frame layout upon enter to function:
  <arg 0>
  <arg 1>
  ...
  <arg n> <-- $sp
upon enter, $fp is saved on the stack, then $fp <- $sp, and finally locals are allocated. So after all of that, we have this:
  <arg 0>
  <arg 1>
  ...
  <arg n> <-- $fp
  <old $fp>
  <local 0>
  <local 1>
  ...
  <local n> <-- $sp

Function prolog/epilog is responsible for saving any registers (including $r3) that need to be preserved across calls or for returns.

Function epilog restores return address in $r3, $sp and finally returns by executing $pc <- $r3.

Exception handling returns are in $r4...$r7 (described in EH_RETURN_DATA_REGNO)

TRAMPOLINE
==========

Trampolines are used to call nested functions through a function pointer. Most of the machinery for that
is handled by GCC, but there's a little piece of code that's needed:

The static chain is maintained in $r14 (STATIC_CHAIN_REGNUM).

The trampoline is a little piece of code that's copied into a memory buffer then modified.
The template for it is the following:

    $r14 <- mem[.Lstatic_chain]
    $pc <- mem[.Lfunc_address]
  .Lstatic_chain:
    .long 0
  .Lfunc_address:
    .long 0

This template is first copied to a memory buffer, .Lstatic_chain and .Lfunc_address are then filled
in with the correct value and finally a jump is generated to the beginning of the buffer.

Now, for this functionality to work, we'll need to flush the icache (once we have such a thing) and
the dcache (if it's write-back) to ensure proper execution. We have self-modifying code here...


MEMORY LAYOUT
=============
Page 0 is reserved (to catch NULL-ptr dereference)
Entry point is at 0x1000
Stack starts at 0x40000000
  This is set in interp.c in sim_open as the highest addressable memory address
  This is also defined in the linker scripts through the .stack section, which
  is ultimately set in ld/emulparams/elf32brew.sh.
Heap starts at the end of 'static data'.







We'll need to make sure we use sign-extend loads appropriately: apparently Moxie didn't have sign-extend loads

TODO: brew.opt needs to be updated to actually generate mfloat and mno-float options.

TODO: add floating point instructions (probably for something like fastmath only)

TODO: figure out if we really need 'upper' version of multiplies and how to efficiently use them. Right now 64-bit multiplies are borken, I think.



TODO: we probably want to control register allocation order:

/* The order in which registers should be allocated.
   It is better to use the registers the caller need not save.
   Allocate r0 through r3 in reverse order since r3 is least likely
   to contain a function parameter; in addition results are returned
   in r0.  It is quite good to use lr since other calls may clobber
   it anyway.  */
#define REG_ALLOC_ORDER						\

TODO: we should also use this:

CALL_REALLY_USED_REGISTERS instead of CALL_USED_REGISTERS -> that's legacy.

TODO: there's a GCC macro: __REGISTER_PREFIX__. If there's a GAS equivalent, maybe we can coerce GAS expression parser to stop at register names?
