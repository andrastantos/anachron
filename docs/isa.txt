ISA
=============================================
There are a few ideas to explore in this processor design:

- We have 15 addressable registers, instead of 16. This allows us to use the 16th code (0xf) to be used as an
  escape to gain all sorts of compact, yet easy to decode spaces in the instruction code
- We have two execution contexts: one, called TASK mode, the other, called SCHEDULER mode
- We don't have interrupt enable/disable instructions. Instead, in TASK mode interrupts are always enabled
  while in SCHEDULER mode interrupts are always disabled
  This means that the processor should spend very little time in SCHEDULER mode, essentially just as much
  as it needs to figure out what to do next, and tee up the appropriate task to handle the situation.
  This is where the naming of the two contexts are coming from: SCHEDULER mode is used for - essentially -
  task switching only, and all useful work (including OS functionality) happens in various TASK contexts.
- Each context has it's own program counter (TPC and SPC).
- Switcing between contexts happens using interrupts (TASK -> SCHEDULER), exceptions (TASK -> SCHEDULER)
  and instructions (switches either way).
- Every instruction can be executed with the exact same semantics in both TASK and SCHEDULER mode. Protection
  is achieved by two key concepts:
  - There is a slight imbalance in the ISA: there is a way to influence the current contexts' PC and
    TPC, there is no way to influence SPC (unless of course that happens to be the current context PC)
  - All resources (I/O, memory, even CSRs) are accessed through memory references. These references go through
    an MMU, which controls per-task access rights. This way OS tasks can have higher access to system resources
    then user code. SCHEDULER mode accesses also go through the MMU, but use a different page table address.
    The switch between TASK and SCHEDULER mode MMU page tables is automatic, so when SCHEDULER mode gains
    back execution, it's not limited to the access rights of the last executed task.
- There is no interrupt or exception vector. Instead, when TASK mode execution gets interrupted, SCHEDULER
  mode execution continues from the current SPC. Since the only way to return from SCHEDULER mode to TASK mode
  is by the use of the STU instruction, this means that after an interrupt or exception, executing continues
  in SCHEDULER mode after this STU instruction. SCHEDULER mode code needs to be written as an endless loop,
  where STU can be thought of as a procedure call.
- The ISA strictly operates on the 2-read;1-write port register file principle. This means no PUSH/PULL primitives
  (as PULL would require two writes into the register file).
- The ISA doesn't have CALL/RETURN primitives either (again, return would require two writes).

TODO: if we have floating-point support, we need condition-code registers! See gcc/config/brew/brew.h AVOID_CCMODE_COPIES and how Moxie does it!
TODO: we probably want a +2;+4 and a -2;-4 variant as well if we can find a 16-bit slots for them.

INSTRUCTION ENCODING
=============================================

There are two encoding variants:

16-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

48-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |  |                                                            FIELD_I                                                            |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

FIELD_C normally contains the instruction op-code
FIELD_B normally contains the register index of the second operand
FIELD_A normally contains the register index of the first operand
FIELD_D normally contains the register index of the destination
FIELD_I normally contains an immediate or a memory offset

The whole 16 bit instruction is referred to as the INST.
The '[]' operator represents sub-fields in verilog notation.
The '{}' operator represents concatenation in verilog notation.
The ':' operator represents range (when that context make sense)

Each of fields C,B,A,D can be 0xf or some other value. This gives us 16 instruction groups. These groups are named by the fields which are not 0xf.
So, for instance group BA would be a group where both FIELD_C and FIELD_D are 0xf, while neither FIELD_B and FIELD_A are.

Register indexes:

0x0:  current mode PC (TPC or SPC depending on the mode0
0x1:  R1
0x2:  R2
0x3:  R3
0x4:  R4
0x5:  R5
0x6:  R6
0x7:  R7
0x8:  R8
0x9:  R9
0xa:  Ra
0xb:  Rb
0xc:  Rc
0xd:  Rd
0xe:  Re
0xf:  reserved

Register aliases:
    SRx: signed version of Rx
    FRx: floating point version of Rx

NOTE: PC is a 31-bit register: the LSB is ignored on write and always reads as 0.

INSTRUCTION SET
=============================================

In the following tables
- '.' means any value in [0x0:0xe], unless specifically listed as a special case.
      Can be a different number at every occurance.



ALU operations:
-------------------------------

Form A (group CBAD):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION
-----------------------------------------
0x0...             R_D = R_B ^ R_A             *special cases:
0x0000             FILL                           enters privileged mode, disables interrupts - used to fill unused code-pages; TPC points to the next instruction
0x0110             BREAK                          enters privileged mode, disables interrupts - used for SW breakpoints; TPC points to the next instruction
0x0220             SYSCALL                        enters privileged mode, disables interrupts - used for SYSCALL-s; TPC points to the next instruction
0x0330             STU                            enters user mode, enables interrupts; SPC points to the next instruction
0x0440:0x0cc0      SII                            enters privileged mode, disables interrupts - used to indicate invlid instructions; TPC points to the CURRENT instruction
0x0dd0             FENCE                          ensures that all memory references are completed before continuing
0x0ee0             WFENCE                         ensures the write queue is fully flushed before continuing
0x1...             R_D = R_B | R_A             **special cases:
0x1000             WOI                            wake on interrupt (program visible behavior is the same as PC=PC or PC, can apply power saving)
0x2...             R_D = R_B & R_A
0x3...             R_D = R_B - R_A
0x4...             R_D = R_B + R_A
0x5...             R_D = R_B << R_A
0x6...             R_D = R_B >> R_A
0x7...             SR_D = SR_B >> R_A          signed right shift
0x8...             SR_D = SR_B * SR_A          signed multiply, lower half     #special cases:
0x80..             TPC = R_A or R_D = TPC         R_D = R_A, but A and D references TPC instead of PC, when set to 0.
0x9...             R_D = R_B * R_A             unsigned multiply, lower half   ##special cases:
0x90..             R_D = R_A + 1                  R_D = R_A + 1
0x9.0.             R_D = R_B - 1                  R_D = R_B - 1
0x9..0             SII
0x900.             SII
0xa...             SR_D = UPPER SR_B * SR_A    signed multiply, upper half     ###special cases:
0xa0..             R_D = -R_A                     R_D = -R_A (neg)
0xa.0.             R_D = ~R_B                     R_D = ~R_B (not)
0xa..0             SII
0xa00.             SII
0xb...             R_D = UPPER SR_B * SR_A     unsigned multiply, upper half   ####special cases:
0xb0..             R_D = BSWAP R_A                R_D = {R_A[7:0], R_A[15:8], R_A[23:16], R_A[31:24]}
0xb.0.             R_D = WSWAP R_B                R_D = {R_B[15:0], R_B[31:16]}
0xb..0             SII
0xb00.             SII
0xc...             FR_D = FR_B + FR_A          ^ special cases:
0xc..0             SII
0xc.0.             R_D = WSI R_B                  sign-extend a byte value in R_B into R_D
0xc0..             R_D = BSI R_A                  word-extend a word value in R_A into R_D
0xc00.             SII            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! THIS IS NEW !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
0xd...             FR_D = FR_B - FR_A          ^^ special cases:
0xd..0             SII
0xd.0.             FR_D = SR_B                    (signed) integer to float conversion
0xd0..             SR_D = FLOOR FR_A              float to (signed) integer conversion with truncation
0xd00.             SII            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! THIS IS NEW !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
0xe...             FR_D = FR_B * FR_A          ^^^ special cases:
0xe..0             SII
0xe.0.             FR_D = 1 / sqrt(FR_B)
0xe0..             FR_D = 1 / FR_A
0xe00.             SII            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! THIS IS NEW !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Pseudo instructions:
NOP: encodes to 0x1111, which is R1 = R1 | R1
R_z = 0: encodes to 0x000z which is R_D = R0 ^ R0
R_z = R_s: encodes to 0x1ssz

Form B (group CBD):
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION
-----------------------------------------
0x0.f.             R_D = R_B ^ VALUE
0x0ff.             R_D = VALUE                       R_B becomes 0 (that is load immediate)
0x1.f.             R_D = R_B | VALUE
0x1ff.             R_D = VALUE                       R_B becomes 0 (that is load immediate) if B == F. if D == 0, target is TPC
0x2.f.             R_D = R_B & VALUE
0x2ff.             SII
0x3.f.             R_D = R_B - VALUE
0x3ff.             SII
0x4.f.             R_D = R_B + VALUE <-------- !!!!!!!!!!!!!!!! THIS IS REDUNDANT (it can be replaced with - where VALUE is negated)
0x4ff.             SII
0x5.f.             R_D = R_B << VALUE
0x5ff.             SII
0x6.f.             R_D = R_B >> VALUE
0x6ff.             SII
0x7.f.             SR_D = SR_B >> VALUE              signed right shift
0x7ff.             SII
0x8.f.             R_D = SR_B * VALUE                signed multiply, lower half
0x8ff.             SII
0x9.f.             R_D = R_B * VALUE                 unsigned multiply, lower half
0x9ff.             SII
0xa.f.             R_D = UPPER SR_B * VALUE          signed multiply, upper half
0xaff.             SII
0xb.f.             R_D = UPPER R_B * VALUE           unsigned multiply, upper half
0xbff.             SII
0xc.f.             FR_D = FR_B + VALUE         ^ special cases:
0xc.f0             SII
0xc0f.             SII
0xcff.             SII
0xd.f.             FR_D = FR_B - VALUE         ^^ special cases:
0xd.f0             SII
0xd0f.             SII
0xdff.             SII
0xe.f.             FR_D = FR_B * VALUE         ^^^ special cases:
0xe.f0             SII
0xe0f.             SII
0xeff.             SII


Form C (group CAD):
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE                       OPERATION
------------------------------------------------------------------------
0x0f..             SII
0x2f..             SII
0x3f..             R_D = VALUE - R_A
0x4f..             SII
0x5f..             R_D = VALUE >> R_A
0x6f..             R_D = VALUE << R_A
0x7f..             SR_D = VALUE >> R_A           signed right shift
0x8f..             SII
0x9f..             SII
0xaf..             SII
0xbf..             SII
0xcf..             SII
0xdf..             FR_D = VALUE - FR_B           special cases:
0xdf.0             SII
0xdf0.             SII
0xef..             SII


NOTE: there are a number of combinations that don't make sense:
    - R_A xor R_B with PC as target
    - R_A and R_B where A == B (that is a move, which can be accompished by or)
    - R_A - R_B where A == B (that's zero, which can be accompished by xor)
    - R_A*R_B with A == 0 or B == 0 (PC)
    - shl, shr, sar with B == 0 (PC)
    - or, and, xor, + * in form C (these are symmetrical operations, so form B is sufficiant)
    There might be others as well.
    Many of these combinations are used as holes to sneak in a few odd-ball instructions
    that otherwise would eat up encoding space. This complicates instruction decode, but
    hopefully not by much: in most cases, both the base and the alternate operation
    can procede, and selected upon write-back (giving us at least one extra decode cycle).

NOTE: there are no 8- or 16-bit variants of these instructions. Use 0- or sign-extend during loads to achive type-conversion.
NOTE: encoding is such that OP-code 0 is FILL

Branches:
-------------------------------

Form A (group CBA):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD            OP_CODE                                    NOTES
------------------------------------------------------------------------------
0x0.0f            PC [+]= OFFSET IF R_B == 0
0x0.1f            PC [+]= OFFSET IF R_B != 0
0x0.2f            PC [+]= OFFSET IF SR_B < 0                 signed compare
0x0.3f            PC [+]= OFFSET IF SR_B >= 0                signed compare
0x0.4f            PC [+]= OFFSET IF SR_B > 0                 signed compare
0x0.5f            PC [+]= OFFSET IF SR_B <= 0                signed compare
0x0.6f:0x0.ef     SII
0x1..f            PC [+]= OFFSET IF R_B == R_A
0x2..f            PC [+]= OFFSET IF R_B != R_A
0x3..f            PC [+]= OFFSET IF SR_B < SR_A              signed compare
0x4..f            PC [+]= OFFSET IF SR_B >= SR_A             signed compare
0x5..f            PC [+]= OFFSET IF R_B < R_A
0x6..f            PC [+]= OFFSET IF R_B >= R_A
0x7..f            SII
0x8..f            SII
0x9..f            SII
0xa..f            SII
0xb..f            SII
0xc..f            SII
0xd..f            PC [+]= OFFSET IF FR_B < FR_B
0xe..f            PC [+]= OFFSET IF FR_B >= FR_B

NOTE: there are a lot of pseudo-op-codes that can be created here. For instance:
      - unconditional branch (B) is possible with OP=0, A = B
      - branch if less-than (BLT and BLTS) can be achieved by BGT and BGTS and swapping A and B fields
      - branch if greater-than-equal (BGTE and BGTES) can be achieved by BLTE and BLTES and swapping A and B fields
      - branch if unsigned greater than zero (BGTZ) is the same as BNEZ
      - branch if unsigned less then or equal to zero (BLEZ) BEQZ

NOTE: there's almost *almost* enough room to make 16-bit-offset branches possible. For that:
     1. Kill floating-point compares
     2. Make MSB of FIELD_C the 16-bit/32-bit determination, except if FIELD_C == 0, in which case the top bit of FIELD_A does the same
     3. Make 0xf..f also a conditional jump as well (right now it's reserved)
     This is all very speculative though: it would complicate instruction fetch and for what?
     A slight reduction in code-size for relative jumps within a function.
     BTW: there's another (rather unpalatable) way as well: shift offset right by one, put the R bit into MSB and if set, make it 16-bit.


PESUDO OPS:

PC [+]= OFFSET
PC {+]= OFFSET IF SR_B >= SR_A
PC {+]= OFFSET IF SR_B < SR_A
PC {+]= OFFSET IF R_B >= R_A
PC {+]= OFFSET IF R_B < R_A
PC {+]= OFFSET IF SR_B == SR_A
PC {+]= OFFSET IF SR_B != SR_A
PC {+]= OFFSET IF FR_B == FR_A
PC {+]= OFFSET IF FR_B != FR_A

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

Form B (group CA):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE                             OPERATION
--------------------------------------------------------------
0x0f.f        PC [+]= OFFSET IF R_A[0] == 1
0x1f.f        PC [+]= OFFSET IF R_A[1] == 1
0x2f.f        PC [+]= OFFSET IF R_A[2] == 1
0x3f.f        PC [+]= OFFSET IF R_A[3] == 1
0x4f.f        PC [+]= OFFSET IF R_A[4] == 1
0x5f.f        PC [+]= OFFSET IF R_A[5] == 1
0x6f.f        PC [+]= OFFSET IF R_A[6] == 1
0x7f.f        PC [+]= OFFSET IF R_A[7] == 1
0x8f.f        PC [+]= OFFSET IF R_A[8] == 1
0x9f.f        PC [+]= OFFSET IF R_A[9] == 1
0xaf.f        PC [+]= OFFSET IF R_A[a] == 1
0xbf.f        PC [+]= OFFSET IF R_A[b] == 1
0xcf.f        PC [+]= OFFSET IF R_A[c] == 1
0xdf.f        PC [+]= OFFSET IF R_A[d] == 1
0xef.f        PC [+]= OFFSET IF R_A[e] == 1

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

Form C (group CB):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                                                            OFFSET                                                         | R |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD        OP_CODE                             OPERATION
--------------------------------------------------------------
0x0.ff        PC [+]= OFFSET IF R_A[0] == 0
0x1.ff        PC [+]= OFFSET IF R_A[1] == 0
0x2.ff        PC [+]= OFFSET IF R_A[2] == 0
0x3.ff        PC [+]= OFFSET IF R_A[3] == 0
0x4.ff        PC [+]= OFFSET IF R_A[4] == 0
0x5.ff        PC [+]= OFFSET IF R_A[5] == 0
0x6.ff        PC [+]= OFFSET IF R_A[6] == 0
0x7.ff        PC [+]= OFFSET IF R_A[7] == 0
0x8.ff        PC [+]= OFFSET IF R_A[8] == 0
0x9.ff        PC [+]= OFFSET IF R_A[9] == 0
0xa.ff        PC [+]= OFFSET IF R_A[a] == 0
0xb.ff        PC [+]= OFFSET IF R_A[b] == 0
0xc.ff        PC [+]= OFFSET IF R_A[c] == 0
0xd.ff        PC [+]= OFFSET IF R_A[d] == 0
0xe.ff        PC [+]= OFFSET IF R_A[e] == 0

R: relative jump. Set to 0 for absolute jump, if set to 1, PC-relative jump

NOTE: over- and under-flows wrap during relative address calculations.
NOTE: in the branch predictor, relative jumps with negative OFFSET VALUE can be assumed to be taken by default. Compilers are encouraged to encode back-edges of loops in this encoding to improve
      branch prediction.

Load/Store
----------

Form A (parts of group BAD): Load/store R_D from [R_B]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |    SOP    |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                   OPERATION
--------------------------------------------------------------
0xf0..        SR_D = MEM8[R_A]          8-bit signed load from MEM[R_A] into R_D
0xf1..        R_D = MEM8[R_A]           8-bit unsigned load from MEM[R_A] into R_D
0xf2..        SR_D = MEM16[R_A]         16-bit signed load from MEM[R_A] into R_D
0xf3..        R_D = MEM16[R_A]          16-bit unsigned load from MEM[R_A] into R_D
0xf4..        R_D = MEM[32][R_A]        32-bit load from MEM[R_A] into R_D
0xf5..        MEM8[R_A] = R_D           8-bit store to MEM[R_A] from R_D
0xf6..        MEM16[R_A] = R_D          16-bit store to MEM[R_A] from R_D
0xf7..        MEM[32][R_A] = R_D        32-bit store to MEM[R_A] from R_D

NOTE: op-codes with D=0xf have confusing decode: on the one hand, they would logically mean load/store from MEM[R_A] to TPC. On the other, since the D field is 0xf, they would
      signal a 48-bit instruction. To resolve this problem - and leave instruction length decode simple - these operations generate an SII


Form C (parts of group BD, group ., group D and group B): Load/store R_D from [VALUE]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 1 |    SOP    | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                   OPERATION
--------------------------------------------------------------
0xf8f.        SR_D = MEM8[VALUE]       8-bit signed load from MEM[VALUE] into R_D
0xf8ff        STPC = MEM8[VALUE]        8-bit signed load from MEM[VALUE] into TPC <-- NO GAS SUPPORT AT THE MOMENT!!!!
0xf9f.        R_D = MEM8[VALUE]         8-bit unsigned load from MEM[VALUE] into R_D
0xf9ff        TPC = MEM8[VALUE]         8-bit unsigned load from MEM[VALUE] into TPC
0xfaf.        SR_D = MEM16[VALUE]       16-bit signed load from MEM[VALUE] into R_D
0xfaff        STPC = MEM16[VALUE]       16-bit signed load from MEM[VALUE] into TPC <-- NO GAS SUPPORT AT THE MOMENT!!!!
0xfbf.        R_D = MEM16[VALUE]        16-bit unsigned load from MEM[VALUE] into R_D
0xfbff        TPC = MEM16[VALUE]        16-bit unsigned load from MEM[VALUE] into TPC
0xfcf.        R_D = MEM[32][VALUE]      32-bit load from MEM[VALUE] into R_D
0xfcff        TPC = MEM[32][VALUE]      32-bit load from MEM[VALUE] into TPC
0xfdf.        MEM8[VALUE] = R_D         8-bit store to MEM[VALUE] from R_D
0xfdff        MEM8[VALUE] = TPC         8-bit store to MEM[VALUE] from TPC
0xfef.        MEM16[VALUE] = R_D        16-bit store to MEM[VALUE] from R_D
0xfeff        MEM16[VALUE] = TPC        16-bit store to MEM[VALUE] from TPC
0xfff.        MEM[32][VALUE] = R_D      32-bit store to MEM[VALUE] from R_D
0xffff        MEM[32][VALUE] = TPC      32-bit store to MEM[VALUE] from TPC


Form D (parts of group BAD, group BA, group AD and group A): Load/store R_D from [VALUE+R_B]

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 1 |    SOP    |       A       |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                         OPERATION
--------------------------------------------------------------
0xf8..        SR_D = MEM8[R_A+VALUE]         8-bit signed load from MEM[R_A+VALUE] into R_D
0xf8.f        STPC = MEM8[R_A+VALUE]          8-bit signed load from MEM[R_A+VALUE] into TPC <-- NO GAS SUPPORT AT THE MOMENT!!!!
0xf9..        R_D = MEM8[R_A+VALUE]           8-bit unsigned load from MEM[R_A+VALUE] into R_D
0xf9.f        TPC = MEM8[R_A+VALUE]           8-bit unsigned load from MEM[R_A+VALUE] into TPC
0xfa..        SR_D = MEM16[R_A+VALUE]         16-bit signed load from MEM[R_A+VALUE] into R_D
0xfa.f        STPC = MEM16[R_A+VALUE]         16-bit signed load from MEM[R_A+VALUE] into TPC <-- NO GAS SUPPORT AT THE MOMENT!!!!
0xfb..        R_D = MEM16[R_A+VALUE]          16-bit unsigned load from MEM[R_A+VALUE] into R_D
0xfb.f        TPC = MEM16[R_A+VALUE]          16-bit unsigned load from MEM[R_A+VALUE] into TPC
0xfc..        R_D = MEM[32][R_A+VALUE]        32-bit load from MEM[R_A+VALUE] into R_D
0xfc.f        TPC = MEM[32][R_A+VALUE]        32-bit load from MEM[R_A+VALUE] into TPC
0xfd..        MEM8[R_A+VALUE] = R_D           8-bit store to MEM[R_A+VALUE] from R_D
0xfd.f        MEM8[R_A+VALUE] = TPC           8-bit store to MEM[R_A+VALUE] from TPC
0xfe..        MEM16[R_A+VALUE] = R_D          16-bit store to MEM[R_A+VALUE] from R_D
0xfe.f        MEM16[R_A+VALUE] = TPC          16-bit store to MEM[R_A+VALUE] from TPC
0xff..        MEM[32][R_A+VALUE] = R_D        32-bit store to MEM[R_A+VALUE] from R_D
0xff.f        MEM[32][R_A+VALUE] = TPC        32-bit store to MEM[R_A+VALUE] from TPC


NOTE: form A with D==0xf is invalid to simplify instruction (length) decode. This combination generates SII
      This means that load/store TPC from register offset can only be achieved using fomr D and VALUE==0


UNUSED:
-------------------------------

parts of group BA:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |                           | 1 | 1 | 1 | 1 |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

group C:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

group CD:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |               |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+


+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 0 |    SOP    | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+


These generate SII operations to allow for further expansion

INSTRUCTION GROUP SUMMARY:
==========================

group CBAD: ALU and special function
group CBD: ALU
group CAD: ALU
group CBA: conditional branch
group CB: bit test branch
group CA: bit test branch
group BAD: load/store
group BA: load/store (some reserved)
group AD: load/store
group BD: load/store
group B: load/store
group A: load/store
group D: load/store
group .: load/store
group C: reserved
group CD: reserved

DECODE NOTES:
=============

Instruction encoding is such that the following condition can be used to determine if the extra 32-bits are needed or not:
  &inst[15:11] | &inst[11:8] | &inst[7:4] | &inst[3:0]

The first read port address of the register file comes from:
  &inst[15:12] ? inst[3:0] : inst[11:8]

The second read port address of the register file comes from:
  inst[7:4]

The write port address of the register file comes from:
  inst[3:0]
  NOTE: TPC and SPC are special and needs special decoding logic: they are written by all sort of weird combos of bit-fields

Branches can be identified by:
  inst[3:0] == 0x0 | inst[3:0] == 0xf
  NOTE: this mis-identifies XMOV, WFLUSH and TPC load/stores as branches, but that's a harmless mistake.

NOTE:
========
CALLs can be implemented by:
R3 = PC+12    // calculate return address - NEW INSTRUCTION
[SP+xxx] = R3 // put return address into stack-frame - WOULD BE NEEDED ANYWAY (if link register needs saving)
SP = SP+xxx   // finalize stack-frame - WOULD BE NEEDED ANYWAY (if any arguments are passed on the stack)
PC = yyy      // jump to the subroutine - WOULD BE NEEDED ANYWAY

// return:
R3 = [SP]     // load return address - WOULD BE NEEDED ANYWAY (if link register needs saving)
SP = SP-xxx   // free stack-frame - WOULD BE NEEDED ANYWAY
PC = R3       // return - WOULD BE NEEDED ANYWAY

Notice how this is only one instructions longer than the link approach as the stack-adjustment and the save/restore of the link register
would be there in most cases anyways.

