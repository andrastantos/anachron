ISA
=============================================
There are a few ideas to explore in this processor design:

- We have 15 addressable registers, instead of 16. This allows us to use the 16th code (0xf) to be used as an
  escape to gain all sorts of compact, yet easy to decode spaces in the instruction code
- We have two execution contexts: one, called TASK mode, the other, called SCHEDULER mode
- We don't have interrupt enable/disable instructions. Instead, in TASK mode interrupts are always enabled
  while in SCHEDULER mode interrupts are always disabled
  This means that the processor should spend very little time in SCHEDULER mode, essentially just as much
  as it needs to figure out what to do next, and tee up the appropriate task to handle the situation.
  This is where the naming of the two contexts are coming from: SCHEDULER mode is used for - essentially -
  task switching only, and all useful work (including OS functionality) happens in various TASK contexts.
- Each context has it's own program counter (TPC and SPC).
- Switching between contexts happens using interrupts (TASK -> SCHEDULER), exceptions (TASK -> SCHEDULER)
  and instructions (switches either way).
- Every instruction can be executed with the exact same semantics in both TASK and SCHEDULER mode. Protection
  is achieved by two key concepts:
  - There is a slight imbalance in the ISA: there is a way to influence the current contexts' PC and
    TPC, there is no way to influence SPC (unless of course that happens to be the current context PC)
  - All resources (I/O, memory, even CSRs) are accessed through memory references. These references go through
    an MMU, which controls per-task access rights. This way OS tasks can have higher access to system resources
    then user code. SCHEDULER mode accesses also go through the MMU, but use a different page table address.
    The switch between TASK and SCHEDULER mode MMU page tables is automatic, so when SCHEDULER mode gains
    back execution, it's not limited to the access rights of the last executed task.
- There is no interrupt or exception vector. Instead, when TASK mode execution gets interrupted, SCHEDULER
  mode execution continues from the current SPC. Since the only way to return from SCHEDULER mode to TASK mode
  is by the use of the STU instruction, this means that after an interrupt or exception, executing continues
  in SCHEDULER mode after this STU instruction. SCHEDULER mode code needs to be written as an endless loop,
  where STU can be thought of as a procedure call.
- The ISA strictly operates on the 2-read;1-write port register file principle. This means no PUSH/PULL primitives
  (as PULL would require two writes into the register file).
- The ISA doesn't have CALL/RETURN primitives either (again, return would require two writes).
- Each register has a type associated with it. Unfortunately we don't have decode space to set the type
  during loads, but we do have an instruction to do it after the fact. The ISA specifies that loads don't
  change the type of the destination register. This means that the compiler is best to more-or-less dedicate
  types to certain registers and keep them in that type as long as possible. This would be much easier if
  there were a bunch of registers, with only 15, it might be a little tricky. The type then determines the
  operations associated with various opcodes, especially in the unary, binary ALU groups and in conditional
  branches.

INSTRUCTION ENCODING
=============================================

There are three encoding variants:

16-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

32-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |  |                         FIELD_E                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

48-bit instructions:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|    FIELD_C    |    FIELD_B    |    FIELD_A    |    FIELD_D    |  |                                                            FIELD_E                                                            |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

FIELD_C normally contains the instruction op-code
FIELD_B normally contains the register index of the second operand
FIELD_A normally contains the register index of the first operand
FIELD_D normally contains the register index of the destination
FIELD_E normally contains an immediate or a memory offset

The whole 16 bit instruction is referred to as the INST.
The '[]' operator represents sub-fields in verilog notation.
The '{}' operator represents concatenation in verilog notation.
The ':' operator represents range (when that context make sense)

Register indexes:

0x0:  $r0
0x1:  $r1
0x2:  $r2
0x3:  $r3
0x4:  $r4
0x5:  $r5
0x6:  $r6
0x7:  $r7
0x8:  $r8
0x9:  $r9
0xa:  $ra
0xb:  $rb
0xc:  $rc
0xd:  $rd
0xe:  $re
0xf:  reserved

Register aliases:
    $srX: signed version of $rX
    $sp:  alias to $r0
    $fp:  alias to $r1
    $lr:  alias to $r2
NOTE: none of these aliases have (almost) anything to do with HW and only make assembly 4
      unambiguous and/or easier to read. The only exception is that $r0 and $r1 support
      special, compact load-store operation. There's no functional difference, but the
      intent is that by using these instructions to access stack-local variables allows
      much more compact code-size (close to ARM THUMB compactness).

NOTE: $pc and $tpc are 31-bit registers: the LSB is ignored on write and always reads as 0.

REGISTER TYPES
=============================================
The type of the data held in a register is stored as side-band information next to the
register data. The meaning of various instruction codes depend on the register types
they operate on.

Since compilers (at least GCC) don't differentiate between signed and unsigned integer
types, the HW doesn't do that either. This means that certain integer operations
have a signed and an unsigned version.

There are up to 15 register types supported by the ISA, but only the following are
in use at the moment:

Type code     Type        Note
--------------------------------------------
0             INT32       32-bit integer: this is the default type of all registers after reset
1             INT16X2     2-way 16-bit integer vector
2             INT8X4      4-way 8-bit integer vector
3             UINT16X2S   Unsigned, saturated version on INT16X2
4             SINT16X2S   Signed, saturated version on INT16X2
5             UINT8X4S    Unsigned, saturated version on INT8X4
6             SINT8X4S    Signed, saturated version on INT8X4
8             FP32        32-bit float
9             FP16X2      2-way 16-bit float vector



INSTRUCTIONS NEEDED
=============================================
A good list of instructions supported by CUDA cores:

https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions__throughput-native-arithmetic-instructions

- FP16X2 lane-extract
- Widening/narrowing/lane-extract for fixed point types is easy with the lane-swizzle operation
- maybe lane-swizzle with dynamic sizzle (binary op)?

INSTRUCTION SET
=============================================

In the following tables
- '.' means any value in [0x0:0xe], unless specifically listed as a special case.
      Can be a different number at every occurrence.
- '*' means any value in [0x0:0xf]
      Can be a different number at every occurrence.


ALU operations:
-------------------------------

Form A:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

Exception group

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x0000             FILL     SWI0                   enters privileged mode, disables interrupts - used to fill unused code-pages; TPC points to the current instruction
0x0001             BREAK    SWI1                   enters privileged mode, disables interrupts - used for SW breakpoints; TPC points to the current instruction
0x0002             SYSCALL  SWI2                   enters privileged mode, disables interrupts - used for SYSCALL-s; TPC points to the current instruction
0x0003                      SWI3                   enters privileged mode, disables interrupts - used for sotware interrupts; TPC points to the current instruction
0x0004                      SWI4                   enters privileged mode, disables interrupts - used to indicate invlid instructions; TPC points to the current instruction
0x0005                      SWI5                   enters privileged mode, disables interrupts - used to indicate invlid instructions; TPC points to the current instruction
0x0006             SII      SWI6                   enters privileged mode, disables interrupts - used to indicate invlid instructions; TPC points to the current instruction
0x0007             HWI      SWI7                   enters privileged mode, disables interrupts - used to indicate invlid instructions; TPC points to the current instruction

0x0008             STM                             enters task mode, enables interrupts; SPC points to the NEXT instruction
0x0009             WOI                             wake on interrupt
0x000a:0x000e      SII

Atomic group

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x001.             FENCE                        1   ensures that all memory references are completed before continuing

NOTE: inst[0]: ~R-before
      inst[1]: ~W-before
      inst[2]: ~R-after
      inst[3]: ~W-after
      bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)
NOTE: on my implementation: reads amongst themselves and writes amongst themselves are always ordered.
      Since reads flush the write-queue, reads after writes are also ordered.
      The only thing that can really happen is if an outstanding read is followed by an independent
      write. If the write happens to the same address, it is caught by the pipeline and serialized,
      but if the write is to a different address, it can go through and hit the write queue.
      Even that might not really happen, I might just serialize writes after reads too.
      So, fences are not really about memory ordering, but other side-effect ordering. What other
      side-effects are there though? All I/O is memory mapped, even MMU and CSR accesses.
      Exceptions and interrupts are not really side-effects. Instruction fetches would be one thing,
      but those are not really caught here either. So... I don't know... Maybe we don't need this at all??


Branch group

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x002.             $pc <- $rD                      <------- indirect jump: we probably want to encode it to something that's easier to recognize by the branch predictor
0x003.             $tpc <- $rD
0x004.             $rD <- $pc
0x005.             $rD <- $tpc
0x006.:0x00e.      SII

Unary group

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x01..             $rD.* <- $rA.* + 1
0x02..             $rD.* <- $rA.* - 1
0x03..             $rD.* <- -$rA.*
0x04..             $rD.* <- ~$rA.*
0x05..             $rD <- sum($rA.*)
0x06..             $srD.* <- BSI $rA.*; $rfD.* <- 1 / $frA.*
0x07..             $srD.* <- WSI $rA.*; $frD.* <- rsqrt($frA.*)
0x08..             $frD.* <- $srA.*
0x09..             $srD.* <- FLOOR $frA.*
0x0a..             type($rD) <- $rA
0x0b..             $rD <- type($rA)
0x0c..             $rD <- $pc + FIELD_A*2
0x0d..             type($rD) <- FIELD_A
0x0e..

NOTE: We only have reduction sum. Is there any other *really* important reduction op we need?

Binary group

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x1...             $rD.* <- $rA.* ^ $rB.*       1
0x2...             $rD.* <- $rA.* | $rB.*       1
0x3...             $rD.* <- $rA.* & $rB.*       1
0x4...             $rD.* <- $rA.* + $rB.*       9
0x5...             $rD.* <- $rA.* - $rB.*       9
0x6...             $rD.* <- $rA.* << $rB.*      3
0x7...             $rD.* <- $rA.* >> $rB.*      3
0x8...             $srD.* <- $srA.* >> $rB.*    3
0x9...             $rD.* <- $rA.* * $rB.*       9 (?)
0xa...             $rD.* <- ~$rA.* & $rB.*      1  (this is for lane-combining with an inverted predicate)
0xb...             interpolate
0xc...             see below (stack ops)
0xd...             see below (stack ops)
0xe...             see below (mem ops)

NOTE: logical ops ignore type info, except for determining output type
NOTE: if swizzle muxes are inline in the pipeline, instead of a parallel execution unit, it's possible
      to deal with scalar-and-vector combinations, where the scalar gets automatically replicated into
      the right number of lanes before the operation is performed. Similarly, a 2-lane-and-4-lane vector
      situation can replicate the 2-lane vector into 4 lanes before executing the operation.
NOTE: float-and-integer type combinations need to be thought carefully.  Probably +/-/* generate exceptions,
      shifts actually require it (i.e. there $rB has to be integer), logical ops don't care.
NOTE: output type is the type of $rA

Pseudo instructions:
NOP: encodes to 0x2222, which is $r2 = $r2 | $r2
$rD = 0: encodes to 0x1eeD which is $rD <- $r14 ^ $r14
$rD = $rS: encodes to 0x2SSD

Form B:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0x00f.             $rD.*  <- VALUE              1 (type of $rD remains unchanged)         NOTE: this is the unary operator space normally.
0x01f.             $pc  <- VALUE                N/A
0x02f.:0xef.       SII
0x1.f.             $rD.*  <- VALUE ^ $rB.*      1
0x2.f.             $rD.*  <- VALUE | $rB.*      1
0x3.f.             $rD.*  <- VALUE & $rB.*      1
0x4.f.             $rD.*  <- VALUE + $rB.*      9
0x5.f.             $rD.*  <- VALUE - $rB.*      9
0x6.f.             $rD.*  <- VALUE << $rB.*     3
0x7.f.             $rD.*  <- VALUE >> $rB.*     3
0x8.f.             $srD.* <- VALUE >> $rB.*     3              signed right shift
0x9.f.             $rD.*  <- VALUE * $rB.*      9 (?)
0xa.f.
0xb.f.
0xc.f.             see below (stack ops)
0xd.f.             see below (stack ops)
0xe.f.             see below (mem ops)

NOTE: VALUE is assumed to be of the same type as $rB
NOTE: result type is that of $rB (exception for load immediate)

NOTE: << and >> operations where opB is constant can be simulated by multiplies. Because of that, these operations only have one form.
      This does mean though, that the constant needed for certain shifts is larger than what would normally be required
      (i.e. 32-bit instead of 16).

Form C:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       |       D       |  |                         VALUE                                 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION                TYPE VARIATIONS
-------------------------------------------------------------------------
0x0f0.             $rD  <- short VALUE                1     NOTE: this is the unary operator space normally.
0x0f1.             $rD <- lane_swizzle($rA, VALUE)    1     only lower 8 bits of value has any meaning, all selection options are valid, independent of type NOTE: this would be a short, unconditional jump, something that already is possible using conditional branches
0x0f2.:0xfe.       SII
0x1f..             $rD  <- short VALUE ^ $rA          1
0x2f..             $rD  <- short VALUE | $rA          1
0x3f..             $rD  <- short VALUE & $rA          1
0x4f..             $rD  <- short VALUE + $rA          9
0x5f..             $rD  <- short VALUE - $rA          9
0x6f..             $rD  <- short VALUE << $rA         3
0x7f..             $rD  <- short VALUE >> $rA         3
0x8f..             $srD <- short VALUE >> $rA         3    signed right shift
0x9f..             $rD  <- short VALUE * $rA          9 (?)
0xaf..             SII
0xbf..             SII
0xcf..             see below (stack ops)
0xdf..             see below (stack ops)
0xef..             see below (mem ops)

NOTE: VALUE is assumed to be of matching scalar type for $rA. It is sign-extended to 32-bits, then replicated for each lane.
NOTE: result type is that of $rA (exception for load immediate)

VALUE is *always* sign-extended to 32-bits before applying it to the operation.
TODO: we might want to zero-extend for certain operations, such as logical ops.
NOTE: sign-extending a 16-bit constant, then treating it as a float almost certainly don't make any sense.
TODO: The last three op-codes could be used for something else, such as the missing shifts though...

Stack ops
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |            OFS            | A |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION          TYPE VARIATIONS
-------------------------------------------------------------------
0xc**.             MEM[$rA,OFS*4] <- $rD        1
0xd**.             $rD <- MEM[$rA,OFS*4]        1 (destination type remains unchanged)

NOTE: these instructions only allow $r0 ($sp) and $r1 ($fp) as their base register and an offset range of -256...+252.
NOTE: the existence of these ops complicate memory op decode as well as operation size decode, but save
      a *huge* amount of code-space, allowing almost all register spills and fills to be done in two bytes.

Branches:
-------------------------------

Form A:

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       |       A       | 1 | 1 | 1 | 1 |  |                          OFFSET                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION                                   TYPE VARIATIONS
------------------------------------------------------------------------------------------
0x00.f            if any $rA == 0  $pc <- $pc + unmunge(OFFSET)          1
0x01.f            if any $rA != 0  $pc <- $pc + unmunge(OFFSET)          1
0x02.f            if any $srA < 0  $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x03.f            if any $srA >= 0 $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x04.f            if any $srA > 0  $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x05.f            if any $srA <= 0 $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x06.f            SII
0x07.f            SII
0x08.f            if all $rA == 0  $pc <- $pc + unmunge(OFFSET)          1
0x09.f            if all $rA != 0  $pc <- $pc + unmunge(OFFSET)          1
0x0b.f            if all $srA >= 0 $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x0c.f            if all $srA > 0  $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x0d.f            if all $srA <= 0 $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x0a.f            if all $srA < 0  $pc <- $pc + unmunge(OFFSET)          5                signed compare
0x0e.f            SII

0x1..f            if any $rB == $rA   $pc <- $pc + unmunge(OFFSET)       1
0x2..f            if any $rB != $rA   $pc <- $pc + unmunge(OFFSET)       1
0x3..f            if any $srB < $srA  $pc <- $pc + unmunge(OFFSET)       5             signed compare
0x4..f            if any $srB >= $srA $pc <- $pc + unmunge(OFFSET)       5             signed compare
0x5..f            if any $rB < $rA    $pc <- $pc + unmunge(OFFSET)       5
0x6..f            if any $rB >= $rA   $pc <- $pc + unmunge(OFFSET)       5
0x7..f            SII
0x8..f            SII
0x9..f            if all $rB == $rA   $pc <- $pc + unmunge(OFFSET)       1
0xa..f            if all $rB != $rA   $pc <- $pc + unmunge(OFFSET)       1
0xb..f            if all $srB < $srA  $pc <- $pc + unmunge(OFFSET)       5             signed compare
0xc..f            if all $srB >= $srA $pc <- $pc + unmunge(OFFSET)       5             signed compare
0xd..f            if all $rB < $rA    $pc <- $pc + unmunge(OFFSET)       5
0xe..f            if all $rB >= $rA   $pc <- $pc + unmunge(OFFSET)       5

NOTE: for scalar types, FIELD_C MSB (inst[15]) is irrelevant, that is any/all selection doesn't matter
NOTE: comparison type is determined by type of $rA. type of $rB is ignored and assumed to match that of $rA
TODO: maybe we can do lane-replication in case of lane-count mismatch? After all, these are using the ALUs, the same way as binary ops do...

PSEUDO OPS:
    $pc <- $pc + unmunge(OFFSET)
    if $srB >= $srA $pc <- $pc + unmunge(OFFSET)
    if $srB < $srA  $pc <- $pc + unmunge(OFFSET)
    if $rB >= $rA   $pc <- $pc + unmunge(OFFSET)
    if $rB < $rA    $pc <- $pc + unmunge(OFFSET)

unmunge: move LSB to bit position 17, replace LSB with 0 and sign-extend to 32 bits.

Form B (group CA):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       | 1 | 1 | 1 | 1 |       A       | 1 | 1 | 1 | 1 |  |                          OFFSET                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION                                   TYPE VARIATIONS
------------------------------------------------------------------------------------------
0x0f.f        if $rA[0]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x1f.f        if $rA[1]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x2f.f        if $rA[2]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x3f.f        if $rA[3]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x4f.f        if $rA[4]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x5f.f        if $rA[5]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x6f.f        if $rA[6]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x7f.f        if $rA[7]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x8f.f        if $rA[8]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0x9f.f        if $rA[9]  == 1 $pc <- $pc + unmunge(OFFSET)               3
0xaf.f        if $rA[14] == 1 $pc <- $pc + unmunge(OFFSET)               3
0xbf.f        if $rA[15] == 1 $pc <- $pc + unmunge(OFFSET)               3
0xcf.f        if $rA[16] == 1 $pc <- $pc + unmunge(OFFSET)               3
0xdf.f        if $rA[30] == 1 $pc <- $pc + unmunge(OFFSET)               3
0xef.f        if $rA[31] == 1 $pc <- $pc + unmunge(OFFSET)               3

OFFSET is sign-extended to 31 bits, shifted left by one before addition.

Form C (group CB):

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|       C       |       B       | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                          OFFSET                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  FIELD
  CBAD             OP_CODE   OPERATION                                   TYPE VARIATIONS
------------------------------------------------------------------------------------------
0x0.ff        if $rB[0]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x1.ff        if $rB[1]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x2.ff        if $rB[2]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x3.ff        if $rB[3]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x4.ff        if $rB[4]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x5.ff        if $rB[5]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x6.ff        if $rB[6]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x7.ff        if $rB[7]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x8.ff        if $rB[8]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0x9.ff        if $rB[9]  == 0 $pc <- $pc + unmunge(OFFSET)               3
0xa.ff        if $rB[14] == 0 $pc <- $pc + unmunge(OFFSET)               3
0xb.ff        if $rB[15] == 0 $pc <- $pc + unmunge(OFFSET)               3
0xc.ff        if $rB[16] == 0 $pc <- $pc + unmunge(OFFSET)               3
0xd.ff        if $rB[30] == 0 $pc <- $pc + unmunge(OFFSET)               3
0xe.ff        if $rB[31] == 0 $pc <- $pc + unmunge(OFFSET)               3

OFFSET is sign-extended to 31 bits, shifted left by one before addition.

NOTE: in the branch predictor, relative jumps with negative OFFSET VALUE can be assumed to be taken by default.
      Compilers are encouraged to encode back-edges of loops in this encoding to improve branch prediction.

NOTE: some bit-offsets for certain lane types are meaningless. In those cases, the bits to be compared are assumed to be 0.

Load/Store
----------

Form A: Indirect load/store

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 |     MEM_OP    |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                        OPERATION
--------------------------------------------------------------
0xe0..        $srD <- MEM8[$rA]              8-bit signed load from MEM[$rA] into $rD
0xe1..        $rD <- MEM8[$rA]               8-bit unsigned load from MEM[$rA] into $rD
0xe2..        $srD <- MEM16[$rA]             16-bit signed load from MEM[$rA] into $rD
0xe3..        $rD <- MEM16[$rA]              16-bit unsigned load from MEM[$rA] into $rD
0xe4..        $rD <- MEM[32][$rA]            32-bit load from MEM[$rA] into $rD
0xe5..        MEM8[$rA] <- $rD               8-bit store to MEM[$rA] from $rD
0xe6..        MEM16[$rA] <- $rD              16-bit store to MEM[$rA] from $rD
0xe7..        MEM[32][$rA] <- $rD            32-bit store to MEM[$rA] from $rD
0xe8..        $rD <- !MEM[32][$rA]           32-bit unsigned load-reserve (exclusive load)
0xe9..        ?MEM[32][$rA] <- $rD           32-bit store-release (exclusive store)
0xea.0        $pc <- MEM[32][$rA]            32-bit load from MEM[$rA] into PC
0xea.1        INV[32][$rA]                   invalidate cache line for address $rA

NOTE: loads don't change the type of a register.

Form B: Inidirect offset load/store

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 |     MEM_OP    |       A       |       D       |  |                           VALUE                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                              OPERATION
--------------------------------------------------------------
0xf0..        $srD <- MEM8[$rA+VALUE]              8-bit signed load from MEM[$rA+VALUE] into $rD
0xf1..        $rD <- MEM8[$rA+VALUE]               8-bit unsigned load from MEM[$rA+VALUE] into $rD
0xf2..        $srD <- MEM16[$rA+VALUE]             16-bit signed load from MEM[$rA+VALUE] into $rD
0xf3..        $rD <- MEM16[$rA+VALUE]              16-bit unsigned load from MEM[$rA+VALUE] into $rD
0xf4..        $rD <- MEM[32][$rA+VALUE]            32-bit load from MEM[$rA+VALUE] into $rD
0xf5..        MEM8[$rA+VALUE] <- $rD               8-bit store to MEM[$rA+VALUE] from $rD
0xf6..        MEM16[$rA+VALUE] <- $rD              16-bit store to MEM[$rA+VALUE] from $rD
0xf7..        MEM[32][$rA+VALUE] <- $rD            32-bit store to MEM[$rA+VALUE] from $rD
0xf8..        $rD <- !MEM[32][$rA+VALUE]           32-bit unsigned load-reserve (exclusive load)
0xf9..        ?MEM[32][$rA+VALUE] <- $rD           32-bit store-release (exclusive store)
0xfa.0        $pc <- MEM[32][$rA+VALUE]            32-bit load from MEM[$rA+VALUE] into PC
0xfa.1        INV[32][$rA+VALUE]                   invalidate cache line for address $rA+VALUE

NOTE: VALUE is sign-extended before addition
NOTE: loads don't change the type of a register.

Form C: Direct load/store

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 |     MEM_OP    | 1 | 1 | 1 | 1 |       D       |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

  INST        OP_CODE                          OPERATION
--------------------------------------------------------------
0xf0f.        $srD <- MEM8[VALUE]              8-bit signed load from MEM[VALUE] into $rD
0xf1f.        $rD <- MEM8[VALUE]               8-bit unsigned load from MEM[VALUE] into $rD
0xf2f.        $srD <- MEM16[VALUE]             16-bit signed load from MEM[VALUE] into $rD
0xf3f.        $rD <- MEM16[VALUE]              16-bit unsigned load from MEM[VALUE] into $rD
0xf4f.        $rD <- MEM[32][VALUE]            32-bit load from MEM[VALUE] into $rD
0xf5f.        MEM8[VALUE] <- $rD               8-bit store to MEM[VALUE] from $rD
0xf6f.        MEM16[VALUE] <- $rD              16-bit store to MEM[VALUE] from $rD
0xf7f.        MEM[32][VALUE] <- $rD            32-bit store to MEM[VALUE] from $rD
0xf8f.        $rD <- !MEM[32][VALUE]           32-bit unsigned load-reserve (exclusive load)
0xf9f.        ?MEM[32][VALUE] <- $rD           32-bit store-release (exclusive store)
0xfaf0        $pc <- MEM[32][VALUE]            32-bit load from MEM[VALUE] into PC
0xfaf1        INV[32][VALUE]                   invalidate cache line for address VALUE

NOTE: loads don't change the type of a register.


Extension group A:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 |      EXT      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |       C       |       B       |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

These instructions allow for instruction set extensions in the following way: each value of the ESC select an alternative decoding
of the following 16-bits. Since these 16 bits could further allow for an up to 32-bit FIELD_E value, the total instruction length
could be 64 bits. For now, only the following operations are defined:

NOTE: as of now, the simple instruction length decode logic below holds true, even for the extension group: the only defined instructions
are 32-bit long, which is what the length decoding logic signals.


EXT = 0:
  FIELD
  CBAD             OP_CODE   OPERATION       TYPE VARIATIONS
------------------------------------------------------------------------------------------
0x00..            $rD.* <- $rA.* == 0        3
0x01..            $rD.* <- $rA.* != 0        3
0x02..            $rD.* <- $srA.* < 0        5         signed compare
0x03..            $rD.* <- $srA.* >= 0       5         signed compare
0x04..            $rD.* <- $srA.* > 0        5         signed compare
0x05..            $rD.* <- $srA.* <= 0       5         signed compare
0x06..            SII
0x07..            SII
0x08..            SII
0x09..            SII
0x0a..            SII
0x0b..            SII
0x0c..            SII
0x0d..            SII
0x0e..            SII

0x1...            $rD.* <- $rB.* == $rA.*    3
0x2...            $rD.* <- $rB.* != $rA.*    3
0x3...            $rD.* <- $srB.* < $srA.*   5              signed compare
0x4...            $rD.* <- $srB.* >= $srA.*  5              signed compare
0x5...            $rD.* <- $rB.* < $rA.*     5
0x6...            $rD.* <- $rB.* >= $rA.*    5
0x7...            SII
0x8...            SII
0x9...            SII
0xa...            SII
0xb...            SII
0xc...            SII
0xd...            SII
0xe...            SII

Extension group B:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 |    EXT    |      FRACT        | 1 | 1 | 1 | 1 |  |       C       |       B       |       A       |       D       |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

EXT = 0:
  FIELD
  CBAD             OP_CODE   OPERATION                  TYPE VARIATIONS
------------------------------------------------------------------------------------------
0x0...             $rD <- full $rA * $rB >> FRACT       3
0x1...             $srD <- full $srA * $srB >> FRACT    3

Extension group C:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 |      EXT      | 1 | 1 | 1 | 1 |      EXT2     |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

SII

Extension group D:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|      EXT      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |      EXT2     |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

C < 0xa

SII

Extension group E:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|      EXT      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                           VALUE                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

SII

Extension group F:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 |      EXT      |      EXT2     | 1 | 1 | 1 | 1 |  |                           VALUE                               |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

SII

Extension group G:
-------------------------------

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 |      EXT      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                                                             VALUE                                                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

SII

DECODE NOTES:
=============

Instruction encoding is such that the following condition can be used to determine if the FIELD_E is needed or not:
  (&inst[15:11] | &inst[11:8] | &inst[7:4] | &inst[3:0]) && (inst[15:13] != 3'b101) <-- THIS IS NOT TRUE ANYMORE!!!!

The size of FIELD_E == 32 if:
  &inst[15:11] ? &inst[7:4] : (&inst[7:4] & !&inst[3:0])

The first register file read port address of the register file comes from:
  FIELD_A

The second register file read port address of the register file comes from:
  &inst[15:12] | ~|inst[15:8] ? FIELD_D : &inst[11:8] ? FIELD_A : FIELD_B

The register file write port address of the register file comes from:
  FIELD_D
  NOTE: TPC and SPC are special and needs special decoding logic: they are written by all sort of weird combos of bit-fields,
        potentially conditionally in case of conditional branches.

NOTE: these port assignments are rather permissive: in many cases they read values that are then not used by the instruction.

NOTE: the read port logic is a bit asymmetrical: port B has a 3-way mux, while port A has a direct connection to the instruction bits.
      this can be mitigated - if needed - by pre-decoding the mux selection and store it as an extra 4 bits long with the instruction
      either in the instruction queue (when reading from ICache) or during ICache line fills.

Branches can be identified by:
  inst[15:4] = 0x000 | inst[15:4] = 0x002 | (inst[15:12] != 0xf && inst[3:0] == 0xf) | (inst[15:12] == 0x1f && inst[3:0] == 0xf)
  This formula catches a little more than needed, but the rest are SII operations.
  There are quite a lot of simplifcations that can be done here which makes the overall formula less scary:
  ~(|inst[15:6] | inst[4]) | &inst[3:0]

NOTE:
========
CALLs use link registers:
$lr <- $pc+<offset>
$pc <- <callee>

<offset> could be 8, 6 or 4, depending on the encoding size of the call.

Upon entry callee saves $lr if needed (along with all other callee-saved registers per the ABI)
Upon return, all saved registers (including $lr) are restored, then:

RETURN:
$pc <- $r2

Notice how this is only one instructions longer than the traditional link approach as the
stack-adjustment and the save/restore of the link register would be there in most cases anyways.
The splitting of the link into two instruction allows us to not have two forms of all possible
branches, and so all possible branches *can* be calls as well.

INTERPOLATION
=============================================
2D interpolation works the following way:
-----------------------------------------
Inputs:
1. Base and stride register. The lower 4 bits determine
   output (and texture data) type. The next 4 bits determine
   the stride as a power of 2, such that value 0 is a stride
   of 2 and value 15 is 65536. Stride is measured in 32-bit
   quantities. The top 24 bits determine the 256-byte aligned
   base address for the texture.
2. Coordinates. Encoded in (U)FR12P4x2 format, it's two unsigned
   elements denote the fractional coordinates within the texture
3. Element type can be the following:
        SINT32     - ?
        UINT32     - ?
        SINT16     - mono audio processing
        UINT16     - ?
        SINT8      - bump maps
        UINT8      - mono images
        SINT16X2   - stereo audio processing
        UINT16X2   - ?
        SINT8X4    - ?
        UINT8X4    - RGBA images
   NOTE: element types are different from register types due to the
         different needs.
Operation:
1. The four neighbor coordinates are computed and their four 32-bit
   values are loaded.
2. Interpolation is performed between the four values (lane-by-lane)
   using the fractional values of the coordinates. By the nature of the
   operation, the results can't overflow, but signed-ness matter
3. The result is written into the output register
Output:
1. The interpolated value (lane-by-lane)

Overall, this is a binary operation, albeit one that involves 4 memory
reads as well. As such, it's anything but a RISC operation. Probably,
just as others have done it, it should be a tack-on execution unit.

Another (not much better) way of dealing with the problem is to say that the
base/stride registers' lowest 2 bits describe the output type, but that would
mean that the 2D alignment stride will become 64-byte aligned, because the
bottom 6 bits are now used for other stuff.

At the same time, maybe other operations could also benefit from looking at the
result type? Well, here's why they shouldn't: That effectively creates a 3rd
read port into the register file! Our BRAMs are organized as 36-bit wide, so
the type info comes with the value. Now, how would we know the result type??

Maybe even multi-cycle, instead of fully pipelined?

1D interpolation works the following way:
-----------------------------------------
Inputs:
1. Base register. This now simply is a 32-bit DWORD-aligned pointer.
2. Coordinate: Encoded as a (U)FR24P8 value.
3. Element type. Supported values:
        INT32 (signed interpolation),
        INT16X2 (signed interpolation),
        INT8X2 (unsigned interpolation)
Operation:
1. The two neighbor coordinates are computed and their 32-bit values are loaded
2. Interpolation is performed lane-by-lane.
3. The result register is written
Output:
1. The interpolated value (lane-by-lane)

A single binary opcode could be used to encode all of this, because the type
of the coordinate register can be used to determine the 1D/2D interpolation
and the result register type could be used to determine the interpolation type.

This is a bit unusual though: most operations *determine* the output type, while
this one requires it to be set a priori.

SYNCHRONIZATION
===============

GPUs have a *ton* of synchronization operations, but I don't think any of
them are really necessary. The LL/SC primitives with controlled cache-invalidation
and some TCMs for quick access should suffice and would allow to emulate anything
we might want.

At any rate, some material on the subject:
https://gpuopen.com/gdc-presentations/2019/gdc-2019-agtd5-breaking-down-barriers.pdf
https://mynameismjp.wordpress.com/2018/03/06/breaking-down-barriers-part-1-whats-a-barrier/ - write-up of the same slide-deck

Barriers
========
Barriers are between kernels (if needed). The idea is that one kernel should completely
finish before another can start. This is at the level of the thread scheduler, but I think
it still can be implemented, using LL/SC quite easily:

Let's say that Kernel B depends on Kernel A, so none of Kernel Bs threads can start before
all of Kernel As threads completed.

1. The thread scheduler writes the number of threads in Kernel A into a memory location
2. The thread scheduler starts scheduling threads of Kernel A
3. At the end of each thread of Kernel A, an atomic decrement is performed on the thread
   count from (1)
4. The thread scheduler doesn't schedule any threads of Kernel B, until Kernel As counter
   is 0.

This allows for more complex dependency graphs as well as long as each kernel has an individual
counter like that. It also allows the scheduler to keep scheduling threads from independent
threads as long as there is work to be done and still observe the dependencies.

Cache invalidation
==================
I originally thought cache-invalidation should be a (memory mapped) I/O instruction, but I'm not sure
anymore. In reality, it could be rather easily encoded and by flagging a bit in the transaction, the
cache knows it needs to invalidate the line in case of a hit. This also goes through the normal
logical->physical address translation path, which is an extra benefit.

There's still no way to invalidate a single line of the ICache or special instructions to completely
blow away either caches. Those are still available through memory-mapped I/O.

LL/SC implementation
====================
We are taking advantage of the AXI4 exclusive transactions. These are designed to implement exactly these
primitives: https://developer.arm.com/documentation/102202/0200/Atomic-accesses

This pushes the burden of actually making things work to the memory controller(s) but hopefully there's
support for it there already. If not, the following can be done:

- Let's have a BRAM in 8kx1-bit config. The BRAM address is a 13-bit hash of the transaction address.
- The data is a single 'valid' bit.
Operation:
- On exclusive load, the valid bit is set for the corresponding address.
- On exclusive store, the valid bit is checked and the store is cancelled if the bit is clear.
  The valid bit is cleared either way.

If there are multiple ports to a memory, each port will have to have a copy of the above mechanism for each port.
That is to say, the number of BRAMs needed is the number of ports squared.

Each exclusive load on any port sets all the valid bits in the BRAMs for that port.
Each exclusive store does three things:
1. checks if all the bits are set in the BRAMs for that port. If any if cleared, the write fails.
2. simultaneously, clears the valid bit on all *other* ports' BRAMs that are assigned to this port
3. clears the valid bit in the BRAMs (maybe one of them is sufficient) for this port

This protocol I think leaves one cycle uncertainty, that needs to be checked: if a write to the same address
happens in the same cycle on two or more ports, they could still sneak through. This can be avoided if the BRAMs
are operated in 'read-new-value' conflict resolution mode.

SC needs to return a result code, which comes with the write-response on AXI4. Thus, SC stalls until that comes
back, in effect, flushing the write queue.

With this, an atomic increment would look something like this:

retry:
    $rD <- ! MEM[$rA,<ofs>]
    $rD <- $rD + 1
    $rD <- ? MEM[$rA,<ofs>] <- $rD
    if $rD != 0 $pc <- retry # to mimic RiscV behavior, we signal success with 0.

More complex primitives, can be built out of this simple one. Many architectures add things like atomic increment
as a single instruction, the idea being that one can avoid all the traffic between the processor and the memory
controller if these primitives are implemented right there. I don't want to go that far, so I don't have any
of the primitives.


AMD ISA NOTES
=============================

HA! AMD actually documents their ISA:
https://developer.amd.com/wp-content/resources/RDNA2_Shader_ISA_November2020.pdf
https://gpuopen.com/amd-isa-documentation/

There are a lot of data types (especially for textures!!!!), and a lot of memory types.
There seems to be a TCM (they call it LDS). They also seem to indicate that L1 caches
are write-through (thus the benefit of TCM in data-sharing). LDS is shared within a
'work group'. A work-group is whatever is executing on up to 4 SIMD engines, where
each SIMD engine can have up to 32 workitems (thread, maybe?). I don't see any SMT
features on a per CU level, but there is something about it in the 'dispatch processor'.
So, the 32 workitems then must be the SIMT lanes. Vector registers are 32-bit wide, which
would mean that they are per-lane. There seems to be 256 addressable vector registers
and 106 scalar registers (these are NOT per lane). All of these are 32-bit wide.

There are sub-vector data-types (16-bit, two-lanes-in-one-reg) variants.

There is some confusion about register counts in the block diagram and the ISA. That might
have something to do with SMT. If so, there seems to be 4-way SMT capability in the CUs.

The instruction set is mainly a 32-bit one, but with lots of 64-bit or even longer
instructions, especially for vector ops. Some are even 128+bits long!

There are 16 atomic instructions (add/sub...)

Page 91 contains a good diagram of the memory hierarchy.

This thing is anything but simple. There are a *TON* of instructions.

More on synchronization: there is an S_SLEEP and S_WAKEUP pair.
S_BARRIER - thread-group thingy. There is some verbiage around non-created
      and terminated waves.
S_ICACHE_INV - invalidates the whole ICache
S_DCACHE_INV - invalidates the whole (scalar) L0 DCache
S_GL1_INV    - invalidates the GL1 cache whatever that is

NOTE: there's no flush. That seems to indicate:
  - write-through
  - non-coherent
